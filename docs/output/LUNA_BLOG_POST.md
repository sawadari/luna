# Luna：AIネイティブ時代の知識創造プラットフォーム

## なぜ今、開発の仕組み自体を再設計すべきなのか

CursorやAntigravityの登場が示したのは、単に「AIがコードを書いてくれる」という未来ではない。それは、**ソフトウェア開発そのものが「完成させるもの」から「学習し続ける存在」へと変わった**ことを意味している。

しかし、多くの開発チームは、まだ従来の開発プロセスの延長線上でAIを使おうとしている。GitHub CopilotやClaude、ChatGPTを「便利なツール」として部分的に導入する。確かに、コーディングは速くなる。だが、それだけでは、AIネイティブ時代の本質的な競争優位性は築けない。

**問われているのは、「AIが何を書いてくれるか」ではない。「AIと人間が、どう学習し続ける構造を作れるか」である。**

Lunaは、この問いに対する一つの答えである。

---

## 従来の開発プロセスが限界を迎える理由

従来の開発は、こんなフローで進んできた：

1. 要求を詳細に定義する（PRD、仕様書）
2. それをタスクに分解する（Issue、チケット）
3. 実装する（コード、テスト）
4. デプロイする
5. 運用・保守する

このプロセスの前提は、**「完璧な仕様を書けば、意図通りに動くソフトウェアができる」**というものだった。ソフトウェアは決定論的な存在であり、人間が制御できると信じられていた。

しかし、AIをコアに据えたプロダクトでは、この前提が崩れる。

AIは確率論的に振る舞う。同じプロンプトでも、毎回異なる出力を返すことがある。ユーザーのフィードバックや利用パターンによって、振る舞いが変化する。プロダクトは、もはや「完成して出荷されるもの」ではなく、**「リリース後に学習し続ける生態系」**として設計されなければならない。

そして、この変化は、開発プロセス自体を根本から再設計する必要性を突きつけている。

---

## Lunaが実現する「学習し続ける開発」

Lunaは、AIネイティブ時代の開発プロセスを、ゼロから再設計した知識創造プラットフォームである。

### 1. **問題空間と解決策空間を分離する（DEST理論）**

従来の開発では、「何を作るか」と「どう作るか」が混同されがちだった。「ログイン機能を実装する」というIssueが立てられ、そのまま実装に進む。しかし、**その実装が本当に価値を生むのか**という問いは、後回しにされることが多い。

LunaのDEST理論は、この問題を解決する。すべてのIssueは、実装前に以下の2軸で評価される：

- **Outcome（成果軸）**: 目的に近づいているか
- **Safety（安全軸）**: 暴走・増幅の兆候がないか

この2軸から、**保証レベル（AL: Assurance Level）**が決定される：

| AL | 意味 | アクション |
|----|------|-----------|
| **AL2** | 成果・安全の両方が確保されている | ✅ 実装を自動進行 |
| **AL1** | 条件付き保証（不確実性あり） | ⚠️ 人間が最終判断 |
| **AL0** | 保証なし（安全性が確保されていない） | 🚫 実装をブロック |

**AL0と判定されたIssueは、実装されない。** リソースを無駄にしないための、最初のフィルタリングである。

これは、CursorがAIをコアに据えてエディタを再設計したように、**開発プロセス自体をAI時代の前提で再設計する**ということだ。

### 2. **意思決定と知識を循環させる（Planning + SSOT Layer）**

AIネイティブプロダクトの価値は、「どんな機能を持つか」ではなく、「学習がどれだけ健全に回り続けるか」で決まる。

Lunaは、この学習のループを、開発プロセスそのものに組み込んでいる。

#### Planning Layer：意思決定の透明化

従来の開発では、「なぜこの実装を選んだのか」「他にどんな選択肢があったのか」「どんな前提で判断したのか」といった意思決定の経緯が、会議の議事録やSlackのスレッドに散らばっていた。

Lunaは、これを構造化する：

- **Opportunity**: 価値が発生しうる機会の定義
- **OptionSet**: 複数の解決策を集合として保持（単一案への早期コミットを避ける）
- **DecisionRecord**: 採否・延期・探索継続の決定を記録（責任主体と反証条件を必須化）
- **Assumption**: 重要な前提を第一級オブジェクトとして管理（前提が崩れたら再評価）

重要なのは、**評価（測る/推定）と決定（選ぶ）を分離する**ことだ。AIは評価を支援できるが、決定は人間が行う。

#### SSOT Layer：知識の循環と進化

従来の開発では、要求・設計・検証が分断され、「何が最新の正本か」が不明確になりがちだった。

Lunaは、**Kernel**という概念で、すべての知識を一元管理する：

- **Kernel**: 意思決定、要求、設計、検証を一つのオブジェクトとして管理
- **NRVV（Needs-Requirements-Verification-Validation）**: 要求から検証までのトレーサビリティを自動管理
- **Maturity遷移**: draft → under_review → agreed → frozen（成熟度を明示化）

そして、実装結果は**Kernelにフィードバックされる**。テスト結果、コードレビュー結果、デプロイ結果がKernelに記録され、次の意思決定に活用される。

**これが、「データの蓄積」ではなく「データの循環」である。**

### 3. **人間-AI責任分界を明確にする**

AIネイティブプロダクトでは、「人間が何を決め、AIが何をするか」の境界が曖昧になりがちだ。

Lunaは、この境界を**ルールとして明示化**している（`rules-config.yaml`）：

- **Phase 0（DEST Judgment）**: 問題空間の価値判断は**人間の責任**
- **Phase 1（Planning Layer）**: 解決策探索は**人間の意思決定支援が必要**
- **Phase 2（Kernel Generation）**: NRVVはAIが提案、**人間が承認**
- **Phase 4-5（Code Generation & Review）**: 生成コードは**必ず人間がレビュー**

なぜこのような分界が必要なのか？

答えは単純だ。**AIは技術的成立性を評価できるが、ビジネス価値・戦略整合・ステークホルダー影響の最終判断は人間が行う必要がある。**

この原則を、プロダクトではなく**開発プロセス自体**に適用したのがLunaである。

---

## Lunaが作り出すフィードバックループ

従来の開発プロセスは、基本的に「一方通行」だった。要求 → 設計 → 実装 → デプロイ。デプロイ後のフィードバックは、次のスプリントやバージョンで反映される程度だった。

Lunaは、**すべてのフェーズがフィードバックループで繋がっている**：

```
Phase 0: DEST Judgment（問題空間分析）
  ↓ AL判定
Phase 1: Planning Layer（解決策探索）
  ↓ DecisionRecord生成
Phase 2: Kernel Generation（知識管理）
  ↓ NRVV抽出・Kernel固定
Phase 3: Task Decomposition（タスク分解）
  ↓ DAG生成・並列実行計画
Phase 4-5: Code Generation & Review（実装・レビュー）
  ↓ 品質判定・テスト実行
Phase 6-7: Verification & Validation（検証・妥当性確認）
  ↓ テスト結果をKernelにフィードバック
Phase 8: Monitoring（システム監視）
  ↓ メトリクス収集・異常検知
Phase 9: Self-Improvement（継続的改善）
  ↓ 知識蓄積・再評価トリガー
  ↑ Phase 0に戻る（再評価）
```

このループが回り続けることで、**プロダクトだけでなく、開発プロセス自体が学習し続ける**。

具体例を挙げよう：

1. **Issue #100**が作成される（「認証機能の改善」）
2. **DEST判定**で AL0 と判定される（理由：遅れを無視した過剰修正、振動リスクあり）
3. **AL0 Reason検出**で R02（遅れ無視）を特定
4. **標準処方（Protocol P2）**が適用される：「遅れと介入の整合を取る」
5. **Planning Layer**で、Wait/Freeze/Reviseの運用姿勢を設計
6. **DecisionRecord**が生成され、Kernelに固定される
7. 実装後、**テスト結果がKernelのVerificationとして記録**される
8. 次回、類似のIssueが作成されたとき、**過去のDecisionRecordが参照**され、判断が高速化される

これが、「フィードバックループを早く回す」ということだ。

---

## データ・モートとしての知識基盤

CursorやAntigravityの強みは、単にAIがコードを書いてくれることではない。**利用すればするほど、ユーザー固有の文脈を学習し、提案精度が上がる**ことにある。

Lunaも同じである。ただし、Lunaが学習するのは「コードの書き方」ではなく、**「組織の意思決定パターン」「失敗パターン」「成功パターン」**である。

- どんな問題がAL0と判定されたか
- どんな前提（Assumption）が後で覆されたか
- どんな解決策が採用され、どれが拒否されたか
- どんなテストが失敗し、どう修正されたか

これらは、組織固有の知識資産である。そして、**他社が容易に模倣できない競争優位性**となる。

なぜなら、Lunaのアーキテクチャは公開されているが（オープンソース）、**あなたの組織が蓄積したKernelは、あなただけのものだから**である。

---

## AIネイティブ組織への第一歩

sales_input.mdで述べられていたように、「AIネイティブなプロダクトは、AIネイティブな人と組織でなければ作れない。」

Lunaは、この原則を、**開発プロセスそのものに適用したフレームワーク**である。

Lunaを使うことで、組織は以下を得る：

### 1. **意思決定の透明化**

- なぜこの実装を選んだのか
- 他にどんな選択肢があったのか
- どんな前提で判断したのか

これらが、すべてDecisionRecordとして記録される。**新メンバーのオンボーディングが劇的に改善される。**

### 2. **失敗からの学習**

- AL0と判定されたIssueの履歴
- 拒否された解決策の理由
- 無効化された前提（Assumption）

これらが蓄積されることで、**同じ失敗を繰り返さない**組織になる。

### 3. **アジリティの向上**

- DAGベースのタスク分解による並列実行
- Critical Path分析による最適実行計画
- 自律的なエージェント連携

**意思決定から実装までの時間が短縮される。**

### 4. **知識の循環**

- 実装結果がKernelにフィードバックされる
- Kernelが次の意思決定に活用される
- 組織全体の判断速度が上がる

**使えば使うほど、組織が賢くなる。**

---

## Lunaが目指す未来

Cursorは、「AIがコアにあることを前提として、エディタを再設計した。」

Lunaは、「AIがコアにあることを前提として、**開発プロセスを再設計した**。」

プロダクトが「学習し続ける存在」になったように、**開発プロセス自体も「学習し続ける存在」になるべきだ。**

Lunaは、その実現のためのプラットフォームである。

---

## 今日から始められること

Lunaはオープンソースプロジェクトとして公開されている。

**GitHub**: [https://github.com/sawadari/luna](https://github.com/sawadari/luna)

以下のステップで、すぐに試すことができる：

### Step 1: セットアップ（5分）

```bash
git clone https://github.com/sawadari/luna.git
cd luna
npm install
npm run build
```

### Step 2: ルール設定をカスタマイズ（10分）

`rules-config.yaml`を編集して、あなたの組織の人間-AI責任分界を定義する：

```yaml
human_ai_boundary:
  dest_judgment:
    enabled: true
    al_threshold:
      auto_proceed: "AL2"  # AL2以上は自動進行

  code_generation:
    quality_threshold: 80  # 80点以上で合格
    test_coverage_target: 80  # 80%カバレッジ目標

  review_required:
    enabled: true  # 生成コードは必ず人間がレビュー
```

### Step 3: 最初のIssueで試す（15分）

DEST判定フィールド付きでIssueを作成：

```markdown
# 認証機能の改善

## Outcome Assessment
- Current state: ログイン成功率 85%
- Target state: ログイン成功率 > 95%
- Progress: improving

## Safety Assessment
- Feedback loops: stable
- Safety constraints: セキュリティ基準ISO27001準拠
- Violations: none
```

CoordinatorAgentを実行：

```bash
npm run run-coordinator -- --issue 100
```

**Phase 0からPhase 9までの全工程が自動実行される。**

---

## まとめ：完成から循環へ

sales_input.mdで述べられていたように、AIネイティブ時代において問われているのは、「何を作るか」を細かく決めることではない。**AIがどのように振る舞いを変えていくのか、その前提となる構造を設計し、方向を調整し続けること**である。

Lunaは、この原則を開発プロセスに適用した。

- **DEST理論**で、無駄な実装を防ぐ
- **Planning Layer**で、意思決定を透明化する
- **SSOT Layer**で、知識を循環させる
- **Self-Improvement Loop**で、組織が学習し続ける

プロダクトが「完成させて出荷するもの」から「学習し続ける存在」へと変わったように、**開発プロセスも「完成させるもの」から「循環し続ける存在」へと変わるべきだ。**

Lunaは、その第一歩を提供する。

---

**さて、あなたのチームは、どこまで『機能の開発』から『学習する構造と組織の構築』へと軸足を移せているだろうか。**

**Luna: AIネイティブ時代の知識創造プラットフォーム**
GitHub: [https://github.com/sawadari/luna](https://github.com/sawadari/luna)
ドキュメント: [Getting Started Guide](./docs/guides/GETTING_STARTED.md)

---

**著者について**
Lunaは、DEST理論・Planning Layer・SSOT Layerを統合した知識創造プラットフォームです。MITライセンスで公開されており、誰でも自由に利用・改変・配布できます。

**Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>**
