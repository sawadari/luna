
# 第3章 システムとインタフェース

システムとインタフェースシステム(Systcms)とインタフェース(Interfacc)という2つの重要な概念に焦点を当てます。特に、システムの異なる抽象度の重要性と、階層レベルの数を制限する必要性を検討します。システムとそのレベルについて説明した後、インタフェースという重要な概念を導入することにより、これらの異なるレベルが相互作用する方法について説明します。本章の内容は以下の通りです。●システムを定義する本章を通して使用される重要な概念を紹介し、説明します。●インタフェースを記述するさまざまな種類、さまざまなレベルのインタフェースを特定し、定義する方法を紹介します。●フレームワークを定義するこれまでに開発してきたMBSEフレームヮークに適用することで、本章で使用するすべてのビューを高い抽象度で捉えます。システムとインタフェースを理解することは、システム開発において最も重要な側面の1つです。なぜなら、システムとインタフェースこそが、システムモデルの中心的な要素であるためです。あらゆるシステムの基本的な構成要素は、階層を構成するシステム要素と、これらさまざまなシステム要素間のインタフェースです。MBSEのアプローチ全体は、一貫性のあるオントロジーにもとづいています。したがって、さまざまな抽象度を詳細に説明する前に、モデルを構成するすべてのビューが、基礎となるMBSEオントロジーと一貫性をもつことに関してどのように証明するかを理解することが重要です。システムを定義するシステムズエンジニアリングの重要な側面として、システムそのものの定義をできる限り早く確立する必要があります。そのため、まずはシステムとインタフェースに関連する//フ概念と用語を使用し、MBSEオントロジーを定義することにします。これには、重要な用語の特定だけでなく、以下の用語の意味を正確に定義することも含まれます。●システム階層(System Hierarchy)どのような階層レベルが存在するのでしようか?多くの人はサブシステムの概念を思い浮かべるでしようが、サブシステムの下に存在する追加の抽象度について考えることはほぼありません。したがって、それぞれのサブシステムの下に、他にどのようなレベルが存在するかという問題に取り組む必要があります。●システム要素間の相互作用(!nteractions between System Elements)システム同士、サブシステム同士など、類似したシステム要素間でどのような相互作用が存在するでしょうか?●レベル間の相互作用(lnteractbn between levels)階層のレベル間の相互作用、たとえばシステムとサブシステムの間でどのような相互作用が存在するでしょうか?MBSEを成功させるための秘訣は、優れたオントロジー(Ontology)を定義することです。
# 第3章 システムとインタフェース

重要なテーマを説明します。まず、最も単純な階層から説明します。次のダイアグラムを見てください。(ontology element,System<ontology elementlStakeholder<ontology relationship>has an interest in >1<ontology relationshipl1..*<<ontology elementr>Subsystem図3.1 単一レベルの単純なシステム階層図3.1は、SysMLのブロック定義図を使用し、サブシステムという1つ下の抽象度のみをもつ非常に単純なシステム階層(System Hicrarchy)を示しています。システムに関心をもつ利害関係者はシステムと同じ抽象度に位置します。これは、利害関係者とシステムの関係性が、関連(Association)にて視覚化されていることからも推測できます。関連(Association)は、モデル要素が同じレベルで存在していることを示します。一方、システムとサブシステムの関係性は、合成関連(Composition)を使用しています。この合成関連(cOmpOsitiOn)は、サブシステムがシステムよりも低い抽象度に位置することを示します。ブロック定義図を確認する際、これが視覚的にわかりやすい手がかりとなります。合成関連(Compos􈎸on)および後述する集約関連(Aggrcgation)の位置を特定することで、ダイアグラムに存在するさまざまな抽象度をすばやく特定し、最上位の抽象度を簡単に特定することができます。これは、ダイアグラムを読み解くためのよい出発点となります。通常は最上位の抽象度から読み始めるのが自然であり、図3.1は以下のように読みます。「一人以上の利害関係者がシステムに関心をもちます。それぞれのシステムは多数のサブシステムから構成されます」図3.1に存在するSysMLのそれぞれのモデル要素は、本書を通して構築されるMBSEオントロジー全体の一部を構成しています。図3.1のダイアグラムのプロックはオントロジー内の要素を示し、くくontology elemcnt>>というステレオタイプにて視覚化されます。図3.1の関係性、すなわち関連(Association)と合成関連(Compos􈎸on)はオントロジー上の関係性を示し、く<ontology rChiOnShip>>というステレオタイプにて視覚化されます。オ/2/ントロジー全体は、オントロジー要素(Ontology Elcment)とオントロジー関係性(OntologyRel􈎹onship)の組み合わせから構成されます。本書で示すオントロジービューはすべてこのルールに従います。これ以降、わかりやすさとダイアグラムの読みやすさの両方の理由から、<くontologyclement>>ステレオタイプは表示しますが、<くontology rehionship>>は省略します。省略しますが、そのステレオタイプが存在するとみなしてください。図3.1では、システムとサブシステムの間の合成関連(Composition)のみを示しています。これは、システムという概念がそれを構成するすべてのサブシステムを所有することを意味します。ここで、第2章「モデルベースシステムズエンジニアリング」で説明した通り、新しい関係性である集約関連(Aggregation)を追加することで、オントロジーに若干の変化をもたせることができます。(ontology element)Stakeholder<ontology element>System1¨*<ontology element>Subsystemhas an interest in )1…*４■図3.2 合成関連と集約関連をもつ抽象度を示す単純な階層図3.2は、SysMLのプロック定義図を使用し、図3.1と同じような基本階層を示していますが、システムとサブシステムの間に集約関連(Aggrcgation)という新しい関係性を導入しています。このわずかな追加は、システム全体の構造にとって非常に重要な意味をもちます。図3.2は以下のように読みます。「1人以上の利害関係者がシステムに関心をもちます。それぞれのシステムは、そのシステムが所有する多数のサブシステムから構成されます。また、そのシステムが所有していないサブシステムから構成されている場合もあります」これは、システムそのものはサブシステムから構成されてはいますが、これらのサブシ/22
# 第3章 システムとインタフェース

ステムは対象システムが所有している場合もあれば、他のシステムが所有している場合もあることを意味しています。これにより、モデルで実現できるシステムの柔軟性が格段に向上しました。この点を説明するために、いくつかのビューを検討します。図3.3 オントロジーとの一貫性を示す単純な構造分解のビュー図3.3は、SysMLのブロック定義図を使用し、図3.1のオントロジーにもとづいた一貫性のあるビューを示しています。オントロジーと一貫性をもつダイアグラムは有効なビューであると言えます。しかし、オントロジーと一貫性をもたないダイアグラムは単なる画像です。MBSEでは、ビューを画像としてではなく、モデルの一部として作成することが重要であることを忘れないでください。ダイアグラムがオントロジーと一貫性をもつことを示す簡単な方法は、ダイアグラム上のすべての要素がオントロジー要素またはオントロジー関係のインスタンスであることを保証することです。以下を見てください。●運転手(Drivcr)は、オントロジー上にある利害関係者(Stakeholder)のインスタンスです。●「～を運転する(d􈏜es)」は、オントロジー上にある「～に関心をもつ(has all interestin)」のインスタンスです。●自動車(Car)は、オントロジー上にあるシステム(System)のインスタンスです。●シャーシ(Chassis)、ボデイ(Body)、ドライブトレイン(Drlvct􈎹n)、インテリア(Interior)は、オントロジーにあるサブシステム(Subsystem)のインスタンスです。●自動車(Car)とシャーシ(Chassis)、ボディ(Body)、 ドライブトレイン(D􈎸vctrain)、インテリア(Intcnor)の間にある合成関連(Composition)は、オントロジー上にあるシステム(System)とサブシステム(SubsyStem)の間の合成関連(Compos􈎸on)のイdrives )" くくstakeholder)〉Dr:ver<SystemuCar<subsystem>Chassis(subsystem>lDrivetrainく〈subsystem〉〉Body<subsystem>lnterior/2′ンスタンスです。ダイアグラム上のそれぞれの要素はオントロジー要素またはオントロジー関係のインスタンスであるため、図3.3は有効なビューです。またここで重要なことは、同じ図3.1のオントロジーを使用するその他のあらゆるビューとの一貫性も保証されることです。図3.3では、オントロジーから派生したステレオタイプである<<stよeholder>>、く<system>>、く<subsystem>>を使用することで、その一貫性を示しています。関連も同様ですが、見やすくするために、あえて省略しています。これは、オントロジーを強制するためにステレオタイプを使用する良い例であり、モデリングツールを使用して作成されるプロファイル(Pro■ lc)の主要な特徴の1つです。図3.3は、図3.1のオントロジーと一貫性をもっていますが、同様に図3.2のオントロジーとも一貫性をもちます。なぜなら、図3.1は図3.2のサブセットであり、図3.3はサブセットである図3.1と一貫性をもつため、図3.3が図3.2と一貫性をもつということも言えるためです。しかし、次のダイアグラムでは同じことは言えません。0_11(stakeholder)Drlver(System) (subsystem))Bike Rack(subsystem)Chassis(subsystem)Driv€train( subsystem))Body<subsystem>lnterior図3.4 合成関連と集約関連をもつ構造分解のビュー図3.4は、SysMLのブロック定義図を使用し、図3.3で示したシステムをベースにサイクルキャリア(Bikc Rack)を追加して拡張しています。0… 1の多重度により、サイクルキャリア(Bk RЖk)が任意であることを示している点に注意してください。多重度について復習が必要であれば、第2章「モデルベースシステムズエンジニアリング」を確認してください。これまで通りの一貫性チェックを実施し、図3.4が図3.2のオントロジーと一貫性をも′2イ
# 第3章 システムとインタフェース

つことを証明してみましょう。●運転手(Dr􈎺 cr)は、オントロジー上にある利害関係者(Stakcholdcr)のインスタンスです。●「～を運転する(drivcs)」は、オントロジー上にある「～に関心をもつ(has an intcrcstin)」のインスタンスです。●自動車(Car)は、オントロジー上にあるシステム(System)のインスタンスです。●シヤーシ(Chassis)、ボデイ(Body)、ドライブトレイン(Dr􈎺 etraln)、インテリア(Intc􈎸or)は、オントロジー上にあるサブシステム(Subsystem)のインスタンスです。●自動車(Car)とシャーシ(Chassis)、ボディ(Body)、ドライブトレイン(Drivetrain)、インテリア(Interior)の間にある合成関連(Compos􈎸on)は、オントロジー上にあるシステム(System)とサブシステム(Subsystem)の間の合成関連(Composition)のインスタンスです。●サイクルキャリア(Bikc Rack)は、オントロジー上にあるサブシステム(Subsystem)のインスタンスです。●自動車(Car)とサイクルキャリア(Bk R¨k)の間にある集約関連(Aggreg􈎹 on)は、オントロジー上にあるシステム(System)とサブシステム(Subsystcm)の間の集約関連(Aggregation)のインスタンスです。これにより、図3.4と図3.2のオントロジーが一貫性をもつことを示すことができました。しかし、集約関連(Aggregation)は図3.2のみに存在し、図3.1には存在しません。そのため、図3.4と図3.1のオントロジーは一貫性をもちません。これは、MBSEで最も重要な点の1つです。すべてのビューはベースとなるオントロジーと一貫性をもたなければなりません。オントロジーと一貫性がなければ、それはビューでなく、モデルの構成要素の一部ではないということになります。オントロジーにもとづくステレオタイプを使用することで、オントロジーとの一貫性を素早く証明することができます。そのため、本書で示すすべてのビューに対して、MBSEのオントロジーにもとづくステレオタイプを使用します。ここで、「図3.1と図3。2のどちらのオントロジーが正しいのだろう?」という疑間が生じるかもしれません。その答えは「どちらのオントロジーも正しい可能性がある」です。どちらのオントロジーが正しいかは、どのような情報がモデルに含まれるか次第です。図3.1は図3.2ほど多くの情報を含んでいないため、図3.1にもとづくビューは多くの情報を示すことができません。これは図3.1が不正確であるということではありません。重要なことは、オントロジーを定義する際、それぞれのオントロジー要素とオントロジー関連の意味を十分に検討する/2∫ことです。「できるだけ多くの情報をモデリンググすること」が目的ではなく、成功するシステムを提供するのに「十分な情報をモデリンググすること」が目的であることを忘れないでください。システム階層を定義するシステム階層は、より低い抽象度の情報を含むように拡張することができます。次のダイアグラムを見てください。図3.5 階層レベルを拡張するオントロジー図3.5は、SysMLのブロック定義図を使用し、いくつかの新しい階層レベルを定義し拡張したオントロジーを示しています。< communicates withhas an interest in >1¨* 10..*1.,* <ontology element>rStakeholder<ontology element>System1¨*′ヽ‘Υｌｌ‥――<ontology element>Subsystem1..*<ontology element),Assembly1_*<ontology element>Component/2び
# 第3章 システムとインタフェース

それぞれのレベルは、上位レベルと下位レベルを示すことで説明できます。●それぞれのシステム(SyStem)は、そのシステム(System)が所有する多数のサブシステム(Subsystcm)から構成されます(合成関連(Compos􈎸on))。また、そのシステム(Systcm)が所有しない任意のサブシステム(subsystcm)から構成されることもあります(集約関連(Aggregation))。●それぞれのサブシステム(Subsystem)は、そのサブシステム(Subsystem)が所有する多数のアセンブリ(Assembly)から構成されます(合成関連(Compos􈎹 on))。また、そのサブシステム(Subsystcm)が所有しない任意のアセンブリ(Asscmbly)から構成されることもあります(集約関連(AggrcgatiOn))。●それぞれのアセンブリ(Assembly)は、そのアセンブリ(Assembly)が所有する多数のコンポーネント(Component)から構成されます(合成関連(Compos􈎸on))。また、そのアセンブリ(Assembly)が所有しない任意のコンポーネント(Component)から構成されることもあります(集約関連(Aggrcgation))。結果として、システム階層は4つの抽象度をもつことになります。前節で説明した通り、それぞれの階層レベル間の関係は合成関連(Composition)と集約関連(Aggrcgation)の両方で示されます。これにより、それぞれの階層レベルが所有する下位レベルの要素、そしてそれぞれの階層レベルが所有しない下位レベルの要素の両方をもつという柔軟性をもたせることができます。ただし、日標は柔軟性をもたせることではなく、階層に必要なものを表現することであるのを忘れないでください。これらの関係をオントロジーに合めるか否かは慎重に検討される必要があります。これらの関係性の有無は、ビューで視覚化できる正当な関係性を示します。すなわち、存在しない関係性は正当でないことになります。たとえば、オントロジーにあるように、システム(System)が少なくとも1つのサブシステム(Subsystem)から構成されることは明らかに正当です。しかし、以下の関係性は正当ではありません。●システム(Systcm)は複数のアセンブリ(Asscmbly)から構成されます。●システム(Systcm)は複数のコンポーネント(Component)から構成されます。●コンポーネント(Component)は複数のサブシステム(Subsystcm)から構成されます。これらは正当でないとみなされる関係性、すなわち、オントロジーにて示されていない関係性です。トロジー要素とオントロジー関連′2アオントロジーは、ビュー上で視覚化できる」を示します。オントロジー上にないものを視覚化することは禁じられています。図3.4は、オントロジーの正当な視覚化の例であり、モデル全体の一部を構成する有効なビューであると言えます。ここまで、基本的な階層について説明してきました。ここからは、同一階層レベルの要素間での相互作用の関係性を説明します。相互作里の関係性を定義する前節にて基本的な階層を構築しましたが、それぞれの階層間の正当な相互作用の関係性を理解することも重要です。これらの相互作用は、以下のようにオントロジーを拡張することで確認することができます。図3.6は、SysMLのブロック定義図を使用し、それぞれの階層レベルの要素が同一の階層レベルの要素とどのように相互作用するかを示しています。図3.6で示されている相互作用は以下の5種類です。●利害関係者(Stakeholder)から利害関係者(Stakeholder)●利害関係者(Stakeholder)からシステム(System)●サブシステム(Subsystem)からサブシステム(Subsystem)●アセンブリ(Assembly)からアセンブリ(Assembiy)●コンポーネント(Component)からコンポーネント(Component)この場合、このオントロジー上のダイアグラムの関連(Assoc􈎹 on)が、ビューを構成するさまざまな要素間で相互作用する点を特定しています。これは、相互作用する点を明らかにしているだけでなく、相互作用しない点も明らかにしています。重要なことは、オントロジー上で表現されている一行―行のすべてに意味があるということです。たとえば、図3.6では、以下のような相互作用は認められていません。●システム(System)からシステム(System)●システム(System)からサブシステム(Subsystem)●サブシステム(Subsystem)からアセンブリ(Assembly)●アセンブリ(Assembly)からコンポーネント(Component)上記は一例であり、網羅的な一覧を意図しているわけではありません。このオントロジー/2∂< communicates withhas an interest in F1_* 100..オ〈Ｕ(ontoloBy elementyStakeholder<<ontology element>System1..*<tontology element)Subsystern1..*interacts withV1.,*<ontology element)Assembly1..*interacts withV<ontology element))Component1..*interacts withV
# 第3章 システムとインタフェース

図3.6 階層レベル間の相互作用を示す拡張オントロジーにもとづき、システム(System)と他のシステム(SyStem)との間の相互作用が認められていないという事実を確認してみましょう。まず、「本当にシステム(System)と他のシステム(System)との間に相互作用はないのだろうか?」という疑間がすく゛に生じることでしよう。この場合、あるシステム(System)と他のシステム(System)との間の相互作用は、他のシステム(Systcm)を利害関係者(Stakeholdcr)とみなし、利害関係者(Stakcholder)とシステム(System)の関係性として表現されています。これはある組織にとっては正しいかもしれませんが、別の組織にとっては正しくないかもしれません。その場合、あるシステム(Systcm)と他のシステム(Systcm)が相互作用するといった関係性を追加する必要があります。/2フ組織、または組織内の異なるグループにより、同じ概念に対する捉え方が異なるため、「唯一の正しい定義が存在する」という考え方にとらわれてはいけません。重要なことは、あらゆる組織のニーズを満たすオントロジーを作成しようとすることではなく、対象とする組織のドメイン固有言語をオントロジーに正確に反映することです。これらの相互作用は、システム階層内の同じ抽象度のモデル要素間で発生している水平方向の相互作用であることに注意してください。次に説明するのは、システム階層の異なるレベル間(システムからサブシステム、サブシステムからアセンブリ、アセンブリからコンポーネント)に存在する正当でない相互作用です。ここで示したオントロジーでは、異なるレベル間での相互作用は認められていません。これはオントロジーを正しく理解する上で重要な側面です。同一の階層レベル間の水平方向の相互作用と同様、異なるレベル間の垂直方向の相互作用も許容したくなるかもしれません。それ自体に問題はありませんが、モデルの複雑性を管理するということに関して、相互作用の数を制限し、できる限り相互作用を許容しないことが推奨されます。
# 第3章 システムとインタフェース

インタフェースを特定するまずは、システム階層の最下位の3つのレベルの関係性に注目します。次のダイアグラムを見てください。(ontology element)Subsystem1r<ontology element>System Element<ontology elementlAssemblyinteracts with >1..*<ontology element>Component0…*0…*<ontology element>lnterface図3.7 システム要素間の汎用インタフェースを特定する図3.7は、SysMLのブロック定義図を使用し、システム要素(System Elcmcnt)間に存在するインタフェース(Intefacc)の概念を示しています。サブシステム(Subsystem)、ァセンブリ(Assembly)、コンポーネント(Component)を、システム要素(Systcm Element)という新しい汎用的なモデル要素に汎化(Gencralization)した点に注目してください。図3.7は以下のように読むことができます(前述した合成関連(Composition)と集約関連(Aggregation)は、ひとまず置いておきます)。「システム要素(System Element)には、サブシステム(Subsystem)、ァセンブリ(Assembly)、コンポーネント(Component)の3種類があります。それぞれのシステム要素(SystemElemcnt)は、インタフェース(Intc」acc)を介して他の1つ以上のシステム要素(SystcmElcment)と相互作用します」システム要素(Systcm Elcmcnt)の間に「～ と相互作用する(intcracts with)」の関係性があり、l A interacts with B:AはBと相互作用する/′ /この関係性が特化したブロックに継承される点にも注意してください。図3.7のように継承関係を使用することにより、図3.8のような繰り返し表現をする必要がなくなります。1.,*0¨*1_*1(ontology element))Subsystem lnterface(ontology element))Assembly lnterface(ontology elementDlnterface(ontology element)Component lnterface((ontology element)Subsystem1Ainteracts with1¨*(ontology element)Assemblyr1interacts with1¨*(ontology element>rComponentinteracts with >1¨*図3.8 インタフェースの種類を明示的に特定する図3.8は、SysMLのブロック定義図を使用し、システム階層の固有のレベル間のインタフェースを明示的に定義する方法を示しています。図3.8は以下のように読むことができます。「それぞれのサブシステム(subsystem)は、サブシステムインタフェース(Subsystcmlntcrace)を介して、1つ以上の他のサブシステム(Subsystem)と相互作用します。それぞれのアセンブリ(Assembly)は、アセンブリインタフェース(Assembly lntcrface)を介して1つ以上の他のアセンブリ(Assembly)と相互作用します。それぞれのコンポーネント(Component)は、コンポーネントインタフェース(COmpOnCnt lnterfaCe)を介して1つ以上の他のコンポーネント(Componcnt)と相互作用します。サブシステムインタフェース(Subsystem lnterface)、アセンブリインタフェース(Asscmbly lnterfacc)、コンポーネントインタフェース(Component lntcrfacc)は、インタフェース(InterfaCC)の一種です」図3.8のオントロジーは図3.7のオントロジーよりも明らかに複雑です。それぞれのオントロジーの説明からもわかるように、システム要素の汎化(Generdization)を用いたオントロジーは一見してわかりやすいです。しかし、見た目の複雑性だけでなく、それぞれのオントロジーの精密さを検討すること/ノ2
# 第3章 システムとインタフェース

も重要です。図3.7の単純なオントロジーは、図3.8のオントロジーと比較して、より複雑なビューを許容してしまうため、可読性向上のための代償を支払つていると言えます。前節では、モデル要素間の相互作用をより多く許容することが、実際にはモデルの複雑性を高めることにつながるという事実を説明しました。これが今回のケースなのです。汎化(Generalization)により、システム要素(Systcm Element)を定義し、それと相互作用する自己相互作用を定義することで、定義されたインタフェースの種類と関連プロックの数を減らすことができます。しかし、図3.7のオントロジーでは、どのシステム要素(Systcm Element)も他のどのシステム要素(System Elcment)との間でも相互作用できてしまいます。これは、システム要素(Systcm Element)であるサブシステム(Subsystm)が、同じくシステム要素(SystemElcmcnt)であるアセンブリ(Assembly)と相互作用する可能性があることを意味しており、異なるレベル間の垂直的な相互作用を許容していることになります。また、システム要素(System Elemcnt)であるコンポーネント(Componcnt)が、同じくシステム要素(SystcmElemcnt)であるサブシステム(Subsystcm)と相互作用することもできてしまうため、これは2つ以上の異なる階層レベルの間を飛び越えた相互作用となってしまいます。繰り返しになりますが、どちらのオントロジーも正しいのですが、異なるモデリンググ構造を選択することの意味を理解することが重要です。オントロジーをできるだけ簡単にすることが目的ではなく、成功するシステムを提供するのに十分な情報をモデリンググすることが目的であることを忘れないでください。/J′インタフェースを定義するオントロジーは、モデル全体のどこにインタフェースが存在するかを明示的に特定するために使用されます。インタフェースを特定することは重要ですが、インタフェースとは何を意味するのか、インタフェースを表現するためにどのようなビューを使用するのかを正確に定義することも重要です。これは、オントロジーの拡張、特にインタフェース用にオントロジー要素を拡張することで実現できます。次のダイアグラムを見てください。図3.9 インタフェースの概念を定義する2 A exposes B:AはBを公開するA owns B:AはBを所有するA connects to B:AはBと接続するA uses B:AはBを使用する(ontology elementDSystem Elementinteracts with<ontology element))lnterface<ontology element)PortAconnects to(ontology elementlFlow Type<ontology elementrrService Type(ontology element,Flowt<ontology elementrrMessageowns▼1_ネ0¨ =▲exposes 1..*1…*1uses▼l.,*1uses▼1…*aontology element))Port Connector′ノイア
# 第3章 システムとインタフェース

図3.9は、SysMLのブロック定義図を使用し、インタフェース(Intcrfacc)と関連する他のオントロジーを定義することで、インタフェース(Intcrface)の概念をさらに詳細に記述しています。図3.9は、図3.7のオントロジーにもとづいていますが、図3.8のオントロジーとも容易に関連付けることができます。インタフェース(Intc」acc)の定義自体は両者とも同じですが、システム要素(Systcm Element)とポート(Port)との間には「～を所有する(own)」という関係性しか存在せず、ポート(Port)とサブシステム(Subsystem)、アセンブリ(Assembly)、コンポーネント(Componcnt)とのそれぞれの関係性に拡張されたという点が異なります。図3.9は以下のように読むことができます。「それぞれのシステムエレメント(System Element)は、インタフェース(Interface)を介して1つ以上の他のシステムエレメント(System Element)と相互作用します。それぞれのシステム要素(System Element)は0以上のポート(Po■ )を所有し、それぞれのポート(Po■ )は1つ以上のインタフェースを公開します」それぞれのシステム要素(Systcm Elcmcnt)は0以上のポート(Po貢)を所有することができます。すなわち、ポート(Po■ )は任意であり、サブシステム(Subsystcm)、アセンブリ(Asscmbly)、コンポーネント(Componcnt)のいずれであろうとも、ポート(Port)を所有しないシステム要素(Systcm Elcmcnt)である可能性があります。これにより、モデルに柔軟性をもたせることができます。ポートは、2つの要素間の接続点と考えることができます。2つの要素が結合するものは何でもよく、現実の世界では、コンセント、コンピューターのポート、部屋と部屋の間のドア、人の日、耳、指、壁の穴など、さまざまなものが考えられます。ここで重要なことは、「ポート(Po■ )」という言葉から連想されるコンピューターのプラグおよびソケットに限定しないことです。システムズエンジニアの世界では、現実のポートは驚くほど多種多様です。それぞれのポート(PO■)は、ポート(PO■)間で受け渡しできるもの、すなわちサービスまたは物質のフローを示す1つ以上のインタフェース(Interface)を公開しています。これらについては、後ほど詳しく説明します。ダイアグラムを読み進めると、1つ以上のポート(POrt)がポートコネクタ(Port Com∝ tor)を介して他の1つ以上のポート(Port)に接続されることがわかります。ポート(Pm)には、フローOow)を利用するフロー型(I■ow Typc)と、メッセージ(Mcssagc)を利用するサービス型(ScⅣ icc Ty")があります。/ノ∫ここで「1つ以上のポート(Po■)がポートコネクタ(Po■ Conncctor)を介して他の1つ以上のポート(Po■ )に接続される」という文章に注目してみましょう。これはポート(Po■ )がシステム要素(System Elcmcnt)間の接続点であることを強調しています。その接続に使われる媒体をポートコネクタ(Po■ Connector)と呼びます。ポート(Po■)が現実にはさまざまな形をとるように、ポートコネクタ(Po■ Connector)もさまざまな形を取ります。パイプ、ワイヤー、空気、廊下、レンズなどがその例です。ポート(Po■ )には、フロー(Flow)を利用するフロー型(Flow Typc)と、メッセージ(Message)を利用するサービス型(Scr􈎼 ce Type)があり、すべてのポート(Po■ )はこの2種類のいずれかに分類されます。サービス型(Ser􈎼 ce Type)のポート(Po■ )は、メッセージ(Message)を使用します。サービスとは、システム要素(System Element)が利用できる機能のレベルであり、いくつかのプロセスにて実現されると考えることができます。これについては、第5章「システムズエンジニアリングプロセス」の中で、モデリンググプロセスについて説明する際に詳しく説明します。サービスが示すものに応じて、サービスの定義は大きく限定されます。たとえば、ソフトウェアのサービス(多くの人がサービスを参照するときに思い浮かべるもの)、および人間のサービスが考えられます。サービスは、(構造的な構成要素ではなく)振る舞い的な構成要素であり、インタフェースを通して(実際に物質が通過するのではなく)利用でき、インタフェースを通してメッセージの受け渡しができるようになります。フロー型(Flow Type)のポート(Po■ )はフロー(Flow)を使用します。フロー(Flow)とは、あるポート(Por)と別のポート(Pon)の間を移動する物質の通過を示します。フロー(Flow)にはさまざまなものがあり、例として電力、力、流体、気体、人の動き、そしてデータがあります。フロー(Flow)は、(振る舞い的な構成要素ではなく)構造的な構成要素であり、インタフェースを通して(利用できるようになるのではなく)実際に物質が通過します。インタフェースをモデリンググするSysMLを使用してインタフェースをモデリンググする方法を検討します。何かをモデリングする方法は1つではありません。ここで紹介する方法はベストプラクティスにもとづくものです。すべてのモデルと同様に、インタフェースの構造と振る舞いの両方の側面を考慮することが必要です。/ノび
# 第3章 システムとインタフェース

●インタフェースの構造モデリンググを考える場合、インタフェースの特定、インタフェース、ポート、それらに関連するフローおよびサービスの定義、さらにポートの接続の定義が必要です。●インタフェースの振る舞い的なモデリンググを考える場合、ポート間のサービスおよびそれに関連するメッセージのシーケンス、そして存在しうるプロトコルを検討しなければなりません。構造モデリンググおよび振る舞いモデリンググは、多くのビューを作成することで実施されます。それぞれのビューはさまざまなSysMLのダイアグラムを使って視覚化されます。SysML以外の表記法で表現することもできますが、本書はSysMLの表記法のみを使用します。構造分解ビューのモデリンググまずは、ポートを所有するシステム要素ごとに、ポートとそれに関連するインタフェースを特定するビューを紹介します。これにより、全体構造の一部として説明したシステム要素のいずれかを検討することができます。ここでは、第2章「モデルベースシステムズエンジニアリング」で説明した、サブシステムのドライブトレインを構成するアセンブリを検討してみましょう。/リアDrivetrain( assembly,logical))Gearbox( assem bly,logical )Control Unit( assembly,logicah)ChargerIprovides1power for< assembly,logicallMotorr assembly,logica b;Battery1 1<assembly,logica[rCombustion Engine< assembly,logicahrElectric Motordetermines powerratio of?鴫▼1…キprovides power forV図3.10 ドライブトレインのサブシステムの構造分解ビュー図3.10は、SysMLのブロック定義図を使用し、 ドライブトレインのサブシステムの構造分解ビュー(Structural BК よdown Ⅵew)を示しています。ビューとSysMLのブロック定義図によるビューの視覚化を区別することが重要であり、ここでビューという用語を使用していることに注意してください。説明を続ける前に、ビュー(ここでは構造分解ビュー)について確認しましょう。●システムズエンジニア、設計エンジニア、マネジャーを対象にしています。●このビューの目的は、あるサブシステムの概要を提供し、それを構成するアセンブリとそれらの間の関係性を特定することです。●ビューの内容は、1つのサブシステムと1つ以上のアセンブリです。アセンブリは、合成関連(Compos􈎸on)と集約関連(Aggregation)のいずれかにより、選択されたサブシステムに関連付けられます。アセンブリの相互作用の関係性は、アセンブリの種類と共に示される可能性があります。上記を定義することで、図3.10が妥当なビューであることが示されました。3 A determines power nio ofB:AはBの出力比を決定する/′∂111
# 第3章 システムとインタフェース

構造分解ビューは、SysMLのブロック定義図を使用して視覚化されます。図3.10は以下のように読むことができます。「ドライブトレイン(Drivctrain)は、ギアボックス(Gearbox)なし、または1つのギアボックス(Ge=box)、1つもしくは2つのモーター(Motor)、1つの制御装置(Co血ol Unit)、1つもしくは2つのバッテリー(Bmew)から構成され、これらはドライブトレイン(Drivet􈎹n)が所有しています。また、充電器(Charger)なし、または1つの充電器(Chargcr)からも構成され、これらはドライブトレイン(Drivetrain)が所有していません。充電器(Chargcr)は1つ以上のバッテリー(Battcw)を充電し、それぞれのバッテリー(Ba“ery)が制御装置(Co山ol Unit)と電気モーター(Elecmc Motor)の電源となります。制御装置(Co鮨ol Unit)は、ギアボックス(Gca8ox)と2種類のモーター(Motor)、すなわち燃焼機関(Combustion Enginc)と電気モーター(Elcct􈎸 c Motor)の両方を制御します。0または1つのギアボックス(Gcarbox)がモーター(Motor)の出力比を決定します」異なるアセンブリ間の関係を示す際、ビューは潜在的なアセンブリ間のインタフェースを特定するのにも役立ちます。実際にアセンブリ間のすべての関係は潜在的なインタフェースです。インタフェス特ビューのモデリンググインタフェース特定ビュー(Interface ldentincation Ⅵew)にてインタフェースが特定され、インタフェースを個々のシステム要素に割り当てることができるようになります。次のダイアグラムを見てください。→(assembly)Motor<flowPort>MPI: Powerln Portt<flowPort>r MTO:Torque Out Port< servicePort l>MCI: Control Port図3.11 インタフェース特定ビュー:モーターのアセンブリ図3.11は、SysMLのブロック定義図を使用し、モーター(Motor)のアセンブリ(Asscmbly)に焦点を当てたインタフェース特定ビューを示しています。/Jフこのビューを視覚化するためにSysMLダイアグラムのブロック定義図を使用していますが、インタフェースのモデリンググに関するいくつかの高度な構文が使用されています。この例の内容を確認する前に、SysMLの構成要素とその使用方法について説明します。SysMLでは、SysMLのポートを特定することにより、プロック間の接続を説明することができます。ポートはブロックの外枠に重なる小さな四角形で表現されます。図3.11は、3つのポートを示しており、それぞれが接続点を表す小さな四角形で示されており、2種類のポートがあることがわかります。以下を見てください。●標準ポート(Standard Port)単純な長方形(図3.llでは正方形)で表現されます。これにより、SysMLインタフェース、すなわち、SysMLのサービスを容易に特定することができます。インタフェースはポートから出る線で示され、その線にはボール(図3.llでは示していませんが、後の図で示します)またはカップ(図3.11で示しています)が付いています。ボールのインタフェースを提供インタフェース(ボール)、カップのインタフェースを要求インタフェース(カップ)と言います。提供インタフェースは、ブロックにて実現、または提供されるサービスを示します。要求インタフェースは、ブロックが動作するために必要なサービスを示します。●フローポート(Flow Port)矢印が描かれた長方形(図3.11では正方形)で表現されます。フローポートでは流れを表現することができ、長方形の中の矢印は流れの方向を示しています。方向は入力(ブロックの内側に向かう)、出力(ブロックの外側に向かう)、または両方向の矢印で示される入出力(ブロックの内側と外側の双方向に向かう)があります。図3.11には3つのポートが示されています。MPIという名前の入カフローポート、MTOという名前の出カフローポート、MCIという名前のサービスポートがあります。SysMLでは、常にポートは型指定され、型はポート名の隣にあるコロンの右側に表示されます。●MPI入カフローポート(Powerln Pon型)●MTO出カフローポート(Torque Out Po■ 型)●MCI標準ポート(Co前ol Port型)図3.11のビューはインタフェースが存在する場所を特定するのみであり、そのインタフェースの性質を定義するものではないことに注意してください。これについては後ほど説明します。/イθ
# 第3章 システムとインタフェース

最後に、ステレオタイプの使用について説明します。前述した通り、ステレオタイプ(<<>>の中の単語)はビューで実現されているオントロジー要素を参照しています。 ドメイン固有言語であるオントロジーで使用される用語が、話し言葉であるSysMLで使用される用語と非常に似ているため、混乱を招くかもしれません。オントロジーとSysMLの関連付けは以下の通りです。●インタフェース特定ビューは、SysMLのブロック定義図を使用して視覚化されます。●オントロジーのくくassembly>>は、SysMLのブロックにて視覚化されます。●オントロジーの<<OowPo■ >>は、SysMLのフローポートにて視覚化されます。オントロジーの概念とSysMLの構成要素の2つの用語が同じであるため注意してください。●オントロジーのくくserviccPo■>>は、SysMLの標準ポートにて視覚化されます。理解しづらいかもしれませんが、オントロジーの用語と表記法による言語固有の用語を区別することが重要です。インタフェース特定ビューは、他のアセンブリを含むように拡張することができます。以下のダイアグラムを見てください。図3.12 :複数のアセンブリを示したインタフェース特定ビュー図3.12は、SysMLのブロック定義図を使用し、複数のアセンブリを含めたインタフェース特定ビューを示しています。これは、システムを構成する際に標準的な要素のライブラリとして使用可能な非常に有用なビューです。詳細は後ほど説明します。また、提供インタフェース(ボール)と要求インタフェース(カップ)の両方が、異なるアセンブリの定義の一部として示されていることに注意してください。これらのビューは( assembly,logical)Drive Train:tBattery( assembly,logical )(flowPort, BPOl: Control UnitPower Out Port(servicePort DCUCOIj Control Port(flowPort,BPll: Powerln Port(flowPort) BP02:Power Out Port(seryicePort,(flowPortDCUPI: Powerln PortControl Port(flowPort D BPO3IPower Out Port(servicePort DUCO3: Control Port(flowPort ) BPO4:Power Out Port(servicePort,Control Port(flowPort D MTO:Torque Out Port(servicePortDMCli Control Port“now,。rt》EMPl:Powerin Port(flowPortD Et\4TO:Torque Out Port(flowPort,Power (seruicePort,ln POn EMCI: Control Port`〈assembly′ logical),MotOr<assembly,logical>Electric Motor/イ/非常に技術的であり、高度なSysML構文が使用されています。そのため、SysMLの専門家でない人には理解することが難しいかもしれません。これが、ビューの内容を決定する際、どの利害関係者がどのビューを見るのかを検討することが重要であるもう1つの理由です。ポート定義ビュ―のモデリンググポートにてインタフェースを特定できましたので、ポート定義ビュー(Po■ DcnnitionView)でこれらのポートを説明します。次のダイアグラムを見てください。<flow type port)Power ln Portflow propertiesin Power ln図3.13 Powerln Ponに焦点を当てたポート定義ビュー図3.13は、SysMLのプロック定義図を使用し、POwer Ll Po■ というフロー型ポート(low″"po■)に焦点を当てたポート定義ビュー(Port Denttion Ⅵew)を示しています。フロー型ポートは、ブロックの下にフロープロパティ(■ ow pro"􈎹CS)というラベルが付いた特別な区画を使用します。この区画は、ポートを通過するフローを特定するために使用されます。ここでは、Powerlnと名付けられたSysMLのキーワードで示される入カフローを示しています。
# 第3章 システムとインタフェース

Connector_Typeと名付けられています。このプロパティはchar型であり、デフォルト値(不変制約)として3-pinに設定されていることに注意してください。前述の例では、プロパティがポートの物理的な特徴を示しており、ここではポートに関連するコネクタの種類を示しています。サイズ、位置、メーカー、材質、色などの一般的な特徴も含めることができます。もう1つのポートであるサービス型ポート(SeMce Type Po■ )もブロックとして型指定されていますが、異なるSysMLの構文を使用しています。次のダイアグラムを見てください。(service type port>Control PortPower: booleanSpeed_Diff: int = LSpeed_Target: int = 0decrease_speed0: voidincrease_speed0: voidset_speed0: voidswitch_power0: void図3.15 Control Ponのポート定義ビュー図3.15は、SysMLのブロック定義図を使用し、フロー型ポートではなくサービス型ポートのポート定義ビューを示しています。図3.15のプロックには2つの区画があります。以下を見てください。●プロパティ(Propeny)3つの箱の真ん中である最初の区画です。プロパティが型指定され、デフォルト値が設定できます。特にソフトウェアサービスをモデリンググする場合、サービス型ポートのプロパティは、主にサービスにて使用されるデータを示します。●サービス(SeMce)3つの箱の最下位部である2番目の区画です。サービスはSysMLのオペレーションとして示されます。これらのオペレーションは、提供サービスであれ要求サービスであれ、インタフェース上で利用できるサービスを示します。同様に、フロー型定義ビューを作成することにより、フロー型を定義することができます。これについては次節で説明します。/イ′フロー型定義ビ一のモデリンググインタフェースの一部であるフローは、ポート定義ビューと同様の方法で定義できます。次のダイアグラムを見てください。<flowType>Flow TypeNarnei charSyrnboli cha′TypeUniti char<flowType>Torque<<flowType>PowerName: char = PowerSymbol: char = PType: float = 0Unit: char = WattsName: char = TorqueSymbol: char = TType: float = 0Unit: char = Newton metres図3.16 フロー型定義ビュー図3.16は、SysMLのブロック定義図を使用し、フロー型定義ビュー(Flow Ty"Den􈎹lonⅥew)を示しています。図3.16は、以下の4つのプロパテイをもつ汎用フロータイプを示しています。●名前(Name)フロー型の正式名称を示します。ブロックの名前とプロパティ名は同じことが多いため、繰り返しのように思えるかもしれません。しかし、ブロック名は正式名称の省略形であることが多いので、必ずしも同一とは限りません。●シンボル(Symbol)存在する場合はSIシンボル、存在しない場合は短縮形を示します。●型(丁ype)整数、short、long、■oatなどを示します。●単位(Unit)存在する場合は正式なSI単位を示します。/イイ
# 第3章 システムとインタフェース

図3.16のビューには、トルク(TOrquc)とパヮー(POwer)とぃぅフロー型(Flow Typc)の2つの特化(Spccialization)も示されています。それぞれのプロパテイの値が不変制約にて示されていることに注目してください。インタフェース接続ビューのモデリンググこれまで紹介したすべてのビューは、本質的に汎用的です。異なるモデル間で再利用するためのライブラリを作成するために、これらのビューを非常に効果的に使用できる可能性があります。これは、情報を一度だけ定義すれば十分であるということを意味し、モデルを使用する上で非常に効率的な方法です。これにより、多くの時間が節約でき、再利用することにより、自動的にモデルに一貫性が適用されます。これらのライブラリを再利用する主な方法の1つは、さまざまな構成の定義を可能にするため、さまざまなインタフェース接続ビューを作成することです。SysMLでは、プロック定義図または内部ブロック図を使用する2つの方法があります。次のダイアグラムはプロック定義図の例です。(assembly,logical)Electric Motorくくassernbly′ logical〉〉control unit(assembly,logical))Battery<flowPort> EMPI:Power ln PortくくЛovvType〉)Povver<flowPort> EMTO:Torqur Out Port<servicePort> EMCI : Control Portく(servicePort〉)CUC01:Control Port<flowPort> CUPI: Power ln Port<flowType>Power<flowPort> BPO2: Power Out Port<flowPort> BPOl:Power Out Port図3.17 インタフェース接続ビュー:ブロック定義図を使用したドライブトレインの構成例/イ∫図3.17は、SysMLのブロック定義図を使用したインタフェース接続ビューであり、ドライブトレインの構成例を示しています。接続は、ほぼプロック定義図のみで表現可能です。なぜなら、システム要素のとりうる構成は1つのみであり、それぞれのブロックに対してインスタンスが1つのみであるためです。ダイアグラム上のフローポート同士をSysMLのコネクタ(Connector)で接続し、そのコネクタの線にフロー型(くくFlowType>>)として型指定されたアイテムフロー(item 110W)を黒塗りの三角形で示しています。図3.17では、アイテムフローは電力(Powcr)です。フローポートの定義には互換性が必要であり、ダイアグラム上の入カフローと出カフローが対応していなければなりません。これらのポートは必ずしも同じ型である必要はありませんが、フローは一貫性をもつ必要があります。また、それぞれのポートの入出力が逆であったとしても、同じ型定義を使用することができます。たとえば、2つのポートが同じ型定義で1つのフローをもつ場合、一方は出カフロー、もう一方は入カフローとなります。同じフロー型ですでに方向を指定している場合、同じフローの方向しか指定できず、このまま型を適用するだけでは問題になります。この場合、一方のポートにチルダ(～ )を追加し、共役ポート(ConJugatcd POr)とすることで解決できます。共役ポートとは、同じポートの定義を使用しながら、入カフローと出カフローを逆転させたポートのことです。共役ポートを使用する場合、ダイアグラム上のポートの横にチルダ(～)が表示され、ポート内の方向矢印が逆になります。サービスポート同士を接続する場合には、カップとボールの記号で要求インタフェースと提供インタフェースを示し、これらを同じ型にする必要があります。また、提供インタフェースは要求インタフェースのみに接続でき、他の提供インタフェースに接続することはできません。カップとボールのシンボルは、これを視覚的に示す簡単な指標となります。一般的には、接続は内部ブロック図で示します。次のダイアグラムを見てください。/イび(subsystem)Reserve Battery: Drivetrain(flowPort) EMPIPower ln Port“■owPo薇〉)EMTO:Torque Out Port(servicePort) CUCOL:Control Port(flowPort) BPO2:Power Out PortPawer Out Port(assem bly,physical): Electric Motorcontrol unit(servicePort DEMCI: Control Port(flowPort, CUPI:Power ln Port(flowPort) BPOl:Power Out PortPrimary: Battery(flowPort) BPO2Pow€r Out PortBackup: Battery( flowPort)
# 第3章 システムとインタフェース

図3.18 インタフェース接続ビューl内部ブロック図を使用したドライブトレインの構成例図3.18は、SysMLの内部ブロック図を使用したインタフェース接続ビューであり、 ドライブトレインの構成例を示しています。内部ブロック図では、SysMLの非常に強力な概念であるパート(P額)を使用します。SysMLでは、モデル化できる概念の抽象度として、以下の3つのレベルがあります。●SysMLのブロック(Block)概念を最上位レベルとして視覚化することができます。たとえば、ブロックは自動車という概念を示すために使用されます。SysMLの構文ではCarというプロックとして示され、ブロック名は長方形の中に記述されます。●SysMLのパート(Pan)システム要素の構成を示すため、インスタンスの集合を視覚化することができます。たとえば、自動車という一般的な概念にもとづいた複数の構成があり、それが自動車のインスタンスのテンプレートとなります。SysML構文では、Bongo:Carというパートとして示され、コロン(:)の左側にパート名、右側に関連するブロック名が記述されます。●SysMLのインスタンス(lnstance)システム要素の実例を可視化することができます。/イアたとえば、実際に購入した自動車を所有し、運転することができます。SysML構文では、「』:Qn≦≧r:Bongo:Car」、 または「onsCar:Car示されます。コロン(:)が使われていますが、今回は名前全体に下線が引かれており、パートではなくインスタンスであることを示しています。ブロック名と同様にパーツ名を表示するかどうかの違いだけですので、いずれを使用しても問題ありません。内部ブロック図では、パートを使用することで構成を特定することができます。図3.18には、予備バッテリー:ドライブトレイン(ReseⅣc Bmcry:Drivetrain)という大きな箱がありますが、実際には、 ドライブトレイン(Drivctran)ブロックの予備バッテリー(RcserveBattew)パーツを示しています。視覚的には、大きなブロックの中に他のパーツがいくつか含まれているようなイメージです。あるブロックと合成関連(Composition)または集約関連(Aggregation)をもつあらゆる要素をそのブロックのパートとして示すことができます。その場合、合成関連(Composition)または集約関連(Aggregation)の線を明示的に示す必要はありません。図3.18は、 ドライブトレイン(Drivctrain)のパートが以下を含んでいることを示しています。● 1つの電気モーター(日ectrlc Motor)パートコロン(:)の左側に何も表示されないので、名前のないパートです。これは間違いなくパートですが、モデラーが区別するための名前は必要ないと判断しています。● 1つの制御装置(Control Unit)パートこれも名前が表示されていないため、名前のないパートです。●2つのバッテリー(Battery)パートそれぞれのパートの名前が明示的に示され、一方はプライマリ(mmary)、もう一方はバックアップ(Backup)です。バッテリー(Battcry)のように、1つのブロックに対して複数のパートを同じ構成で示すことができるため、内部ブロック図によるインタフェース接続ビューは非常に有用です。図3.18のビューは、図3.10で示された構造分解ビューと一貫性をもっています。また、1つの構造分解ビューに対して複数のインタフェース接続ビューを示すことができることに注意してください。内部ブロック図を使用してさまざまなパートの構成を検討することで、ブロックの内部接続と関係性を分析し、特定することができます。内部ブロック図では、合成関連(Compos􈎸on)を実線、集約関連(Aggregation)を破線ノイ∂というインスタンスとして
# 第3章 システムとインタフェース

で示します。これにより、2つの関連を区別することができます。インタフェースのための振る舞いビューをモデリンググするシステムの構造と振る舞いの両方の側面をモデリンググする必要があると前述しましたが、インタフェースも同様です。構造ビューだけでなく振る舞いビューも示さなければなりません。両方のビューが存在しなければ完全なビューとは言えません。インタフェースはシステム要素間の関係性を示すものです。そのため、第2章「モデルベースシステムズエンジニアリング」で説明したSysMLのシーケンス図を使用します。これにより、システム要素間の相互作用をモデリンググできます。構造ビューにもとづき、 ドライブトレインの簡単なシナリオを作成します。次のダイアグラムを見てください。(assembly)Battery(assembly)Control Unit<assembly>Electric Motorcharged{}provide power()CalCulate_Speed()check_speed0図3.19 インタフェース振る舞いビュー:シーケンス図を使用したドライブトレインに関するシナリオ例図3.19は、SysMLのシーケンス図を使用し、 ドライブトレインのシナリオ例を示してアイフswitch_power0Set_Speed()います。前述したように、1つの構造分解ビューとそれに関連する複数のインタフェース接続ビューに対して、複数のインタフェース振る舞いビューを作成することができます。このため、モデル全体のビューの数が大幅に増える可能性があります。ビュー間で一貫性が保たれていることに注目してください。●ライフラインからブロック(Lre‖ nes to blocks)シーケンス図のそれぞれのライフラインは、構造分解ビューのブロックに関連付けられます。●関連との相互作用(lnteractions with assocttons)ブロック間の相互作用は、構造分解ビューのブロック間の関連(Associ􈎹 on)に関連付けられます。●インタラクションの名前からオペレーション(lnteraction names to operations)それぞれのインタラクションの名前は、ポート定義ビューのサービスに関連付けられます。サービスは、ブロック上のオペレーションにて視覚化されます。一貫性を適用することで、インタフェースのためのビューが完全かつ完璧な定義を提供することを保証します。また、シーケンス図に高度な記法を用いることで、さらに詳細な表現ができます。ライフライン(そしてブロック)間の一般的な相互作用を示すだけでなく、これらの相互作用に関係する固有のポートを示すことができます。次のダイアグラムを見てください。/∫θ
# 第3章 システムとインタフェース

図3.20 タフェース振る舞いビュー:高度な記法のシーケンス図を使用したイブトレインに関するシナリオ例図3.20は、図3.19と同一のシナリオ、同一のシーケンス図を使用していますが、いくつかの高度な構文が追加されています。それぞれのライフラインの下に関連するポートが表示され、ポート間の固有の相互作用が示されるようになりました。また、「速度を確認する(chcctspccd)」のような自己相互作用は、内部の相互作用を示すため、元のライフライン上に表示されていることに注意してください。このような内部の相互作用は、親ブロックのオペレーションとして表示されますが、ブロック間ではなく内部のオペレーションであるため、ポート定義上のサービスとして表示されることはありません。図3.20も、構造分解ビューおよびそれに関連するインタフェース接続ビューと一致していますが、さらに詳細な情報を示しています。ダイアグラムが詳細になればなるほど、ダイアグラムを読む人に専門的な解釈が求めら/∫ /ヽンライド(assembly)Battery(assembly)Control Unit(assembly))Electrlc Motor(flowPort, BPI EMCi:Power ln Portcharged()ｒｔ Ｗ″　・¨０‘􈉊■ Ｉ“ 併rflowPort> ControlCUPI: Port Po蔵Out Port Powel ln蔵∵ｉｔ４勲　　」ハリ一ｅｒＷ一０ 一ｐ 一ｅ 一ｄ 一Ｖ 一禦甲ア甲彗‥‐１‐¬ 甲ca lc u I ate_s peed { )set_speed0i ncrease_speed( )check_speed()switch_power0↑: :irllrolswitch_power0deCreaSe_Speed()れることに注意してください。すなわち、高度な構文になればなるほど、SysMLの専門家でない人がダイアグラムを読むことは難しくなるため、高度なSysML構文を使用したダイアグラムについて、どの利害関係者に見せるかを決定する際には注意が必要です。フレームワークを定義するこれまで作成してきたビューは、第2章「モデルベースシステムズエンジニアリング」で詳しく説明した「1枚のスライドのMBSE(MBSE in a slide)」の中央部分を示したものです。それぞれのビューはSySMLを使用して視覚化されており、これは「1枚のスライドのMBSE(MBSE in a slidc)」の右側部分を示したものです。これらのビューを組み合わせることで全体的なモデルとなりますが、これらのビュー間で一貫性をもつことが重要です。一貫性がなければ、それはビューではなく単なる画像です。すべてのビューの定義は、フレームヮークに取り込まれることが重要となりますが、それが「1枚のスライドのMBSE(MBSE in a slidc)」の左側部分に相当します。フレームヮークは、オントロジーとビューポイントから構成されます。本節の目的は、これらのビューポイントが正しく定義されていることを徹底的に確認することです。フレームワークでのビューポイントを定義する
# 第3章 システムとインタフェース

●それぞれのビューの構成および内容はどのようなものですか?ビューポイント定義ビュー(Ⅵewpoint Dcin􈎸 on Ⅵew)を使用して回答することができます。●どのようなルールが適用されていますか?ルールセット定義ビュー(Rulesct Dcnnition View)を使用して回答することができます。フレームヮークが定義できたと主張するためには、上記の質問に回答できなければなりません。これらの質問は、「アーキテクチャフレームワークのためのフレームヮーク(Framework br Architccture namcworks:FAF)」(Holt and Pcrry 2019)と呼ばれる特別なビューのセットを使用して回答することができます。ここでは単純に、それぞれの質問に回答するための固有のビューを作成すると考えてください。以降の節でそれぞれのビューについて説明します。―ムワーコンスビューフレームヮークコンテキストビュー(Framework Contcxt View)は、フレームヮーク全体が必要な理由を示します。フレームヮークに関心をもつ利害関係者を特定し、それぞれの利害関係者がフレームヮークからどのような利益を得ることを望んでいるかを特定します。それぞれの組織には、それぞれ1つのフレームヮークコンテキストビューが存在します。組織ごとにフレームヮークに対するニーズが異なるため、フレームヮークコンテキストビューは組織ごとに異なります。フレームヮークコンテキストビューは、SysMLのユースケース図を用いて視覚化されます。これに関しては、第6章「ニーズおよび要求求」で詳しく説明します。オントロジー定義ビューを定義するオントロジー定義ビュー(Ontology Denn􈎸 on Ⅵew)は、フレームワークに関連するすべての概念と関連する用語をオントロジーとして取り込みます。図3.6でシステムに関係するビューのオントロジーを定義しましたが、実はこのビューがオントロジー定義ビューです。このビューで示されるオントロジー要素は、本章でこれまでに示したビューで使用されたあらゆるステレオタイプを提供しています。/∫′ビューポイントビューを定義するビューポイント関係ビュー(Ⅵewpoint Relationship Ⅵew)は、必要なビューおよびその定義を含むビューポイントを特定します。これらのビューポイントをまとめてパースペクティブ(Perspcctivc)と言います。パースペクテイブとは、共通のテーマをもつビューポイントの集合のことです。本節では、システムおよびインタフェースに関連するビューを定義することに焦点を当てているため、システムパースペクティブ(System Perspectivc)を作成します。これまで説明してきたビューの関係性は次のダイアグラムの通りです。図3.21 システムパースペクティブのビューポイント関係ビュー図3.21は、SysMLのブロック定義図を使用し、システムパースペクティブ(SystemPerspcctivc)のビューポイント関係ビューを示しています。ここで示すビューポイント4 A shows possible scenarios br B:AはBの可能なシナリオを示すA shows possible connguttionsおrB:AはBの可能なコンフィグレーションを示すA dennes lows used on B:AはBで使用されるフローを定義するA deines po■ son B:AはBで使用されるポートを定義するA identines po■ sおrB:AはBのポートを識別する{ identifies ports for1..キ1…*Ashows possibleconfigurations forAdefines portson1・.*1_*1 Adefines flowsused on1.・ホAshows possiblescenarios for1..* 1..*《viewpoint》Structural BreakdownView'point<viewpoint>Port ldentificationViewpoint<viewpoint>Port DefinitionViewpoint<viewpoint>Connectivity Viewpoint<viewpoint>lnterface BehaviorViewpoint<viewpoint>Flow Type DefinitionViewpoint/∫イ
# 第3章 システムとインタフェース

の概念は、第2章「モデルベースシステムズエンジニアリング」の「1枚のスライドのMBSE(MBSE in a slidc)」で紹介されたものです。それぞれのビューは関連するビューポイントをもち、ビューポイントはビューの定義を含みます。ビューポイントを特定すると同時に、ビューポイント間の関係性を特定することも重要です。なぜなら、フレームワークに関連するルールを定義する際にこれらが役に立つためです。また、SysMLの特化(Specialization)を使用し、固有のビューのバリエーションを示すこともできます。次のダイアグラムを見てください。図3.22 より詳細な情報を示すシステムパースペクティブのビューポイント関係ビュー図3.22は、SysMLのブロック定義図を使用し、システムパースペクティブのビューポイント関係ビューを示しています。ただし、図3.22では構造分解ビューポイントが拡張されています。図3.6で示したオントロジーである、システム(System)、サブシステム(Subsystem)、アセンブリ(Asscmbly)、コンポーネント(Componcnt)の4つの抽象度を検討します。構造分解ビューポイントは、3つの抽象度の構造に適用される可能性がありま(perspectjve)System Perspectjve(viewpointDSystem-SubsystemStructure((viewpoint,Subsystem-AssemblyStructure(viewpoint,Structural BreakdownViewpoint(viewpoint)Port ldentificationViewpoint《viewpoint》Assembly- ComponentStru€ture(viewpoint)Con nectivity Viewpoint(viewpoint)Port DefinitionViewpoint(viewpoint)Interface BehaviorViewpoint(viewpointDFlow Type DefinitjonViewpoint1…*1.*forIshows possibleconfigurations forIdefines portsonldefines flowsused onlshows possiblescenarios for/∫∫す。以下を見てください。●システムーサブシステム構造(System―Subsystem Structure)固有のシステムに焦点を当て、どのようにさまざまなサブシステムに分解されるかを示します。●サブシステムーアセンブリ構造(Subsystem‐Assembly Structure)固有のサブシステムに焦点を当て、どのようにさまざまなアセンブリに分解されるかを示します。●アセンブリーコンポーネント構造(Assembly― Component Structure)固有のアセンブリに焦点を当て、どのようにさまざまなコンポーネントに分解されるかを示します。これらは、実際には構造分解ビューポイントの特殊な型であり、ダイアグラム上では特化(Spccialization)を使用して示されています。このレベルの詳細を示す必要は決してありませんが、詳細なレベルを追加してモデルに価値を与えるかどうかは、モデラーの判断次第です。ビューポイントコンテキストビューを定義するビューポイントコンテキストビュー(Ⅵewpoint Context Ⅵew)は、特定のビューポイント、すなわち、「そのビューの集合がなぜ必要なのか?」を示します。また、そのビューポイントに関心をもつ利害関係者を特定し、それぞれの利害関係者がフレームワークからどのような利益を得たいと考えているかを明らかにします。それぞれのビューポイントには、ビューポイントコンテキストビューが存在します。組織の全体的な期待に貢献する必要があるため、それぞれのビューポイントコンテキストビューからフレームワークコンテキストビューヘと追跡されます。そのため、ビューポイントコンテキストビューの集合は、フレームワークコンテキストビューで示された全体的なニーズを満たします。ビューポイントコンテキストビューは、SysMLのユースケース図を使用して視覚化されます。これに関しては、第6章「ニーズおよび要求求」で詳しく説明します。ビューポイント定義ビューを定義するビューポイント定義ビュー(Viewpoint Deinition View)は、ビューポイントに含まれるオ′∫び
# 第3章 システムとインタフェース

ントロジー要素を定義します。●どのオントロジー要素がビューポイント上で許容されていますか?●どのオントロジー要素がビューポイント上で任意とされていますか?●どのオントロジー要素がビューポイント上で禁止されていますか?構造分解ビューポイント、具体的にはシステムーサブシステム構造のビューポイント定義ビューを示します。次のダイアグラムを見てください。図3.23 構造分解ビューポイントのビューポイント定義ビュー:システムーサブシステム構造図3.23は、SysMLのプロック定義図を使用し、構造分解ビューポイントに対するビューポイント定義ビュー、その中のシステムーサブシステム構造を示しています。ビューポイント定義ビューは非常に重要です。なぜなら、このビューは、ビューポイントにて記述されるすべてのビューで、何が許容されるかを正確に定義するためです。このビューポイントは常に以下の情報を含みます。●ビューポイント名く<viewpoint>>でステレオタイプ化された、このビューの中心となるビューポイントの名前を示します。ここで特定されるビューポイントは、図3.22で示されたビューポイント関係ビューに由来するものでなければなりません。●オントロジー要素く<ontology element>>でステレオタイプ化された、いくつかのオントロジー要素を示します。それぞれのオントロジー要素は、図3.6に示すオントロジー定義ビューに由来するものでなければなりません。ビューポイント定義ビューは、1つのビューポイントとオントロジーのサブセットを含んでおり、一見すると非常にわかりやすく見えます。しかし、ビューポイント定義ビュー/∫ア(viewpoint,System-SubsystemStructurehas an interest in >0.率(ontology element)Stakeholder(ontology element)System(ontology element)Subsystem1¨*のオントロジー要素には多くの注意点があります。それぞれのオントロジー要素も非常に重要です。なぜなら、これらがこのビューポイントに出現可能なオントロジー要素であるためです。以下のオントロジー要素を検討してみましょう。●利害関係者(Stakeho!der)は多重度が1であるため、ダイアグラム上に必ず表示されなければなりません。利害関係者(Stよcholder)が任意である場合、多重度は0… 1、または0¨*またはそのバリエーションになります。●利害関係者(Staにholdcr)の多重度が1であるため、ビューポイントに表示される利害関係者(Stよehol“r)が、1人でなければなりません。もし、このビューポイントに複数の利害関係者(Stakeholder)を表示することができるように変更するのであれば、多重度を1..*、またはそのバリエーションに設定する必要があります。●システム(System)は利害関係者(Stよcholder)同様、ダイアグラム上に表示されなければならず、ビューポイントにあるシステム(Systcm)は1つのみでなければなりません。●サブシステム(Subsystem)はビューポイントに表示され、少なくとも1つのサブシステム(Subsystcm)が存在しなければなりません。次はオントロジー関連を検討してみましょう。● 1人以上の利害関係者(Stよcholder)がシステム(System)に関心をもっています。すなわち、ビューポイント上に利害関係者(Stakcholdcr)とシステム(Systcm)の間に関連(Associ􈎹 on)が存在しなければなりません。●それぞれのシステム(Systcm)は、そのシステム(System)が所有する1つ以上のサブシステム(Subsystcm)から構成されます。ビューポイント上にシステム(Systcm)とサブシステム(Subsystcm)の間に少なくとも1つの合成関連(Compos􈎸on)が存在しなければなりません。これは、サブシステム(Subsystem)に1¨*の多重度があり、それが必須であることを示しているためです。●それぞれのシステム(Systcm)は、そのシステム(System)が所有していない0以上のサブシステム(Subsystcm)から構成されます。ビューポイント上にシステム(System)とサブシステム(Subsystem)の間に少なくとも1つの集約関連(Aggrcgation)がある場合とない場合があることを意味します。これは、サブシステム(Subsystem)に0¨*の多重度があり、それが任意であることを示しているためです。ビューポイント定義ビューに存在するオントロジー要素およびオントロジー関連は、そ/∫∂
# 第3章 システムとインタフェース

れにもとづいたすべてのビューの内容を決定するため、十分に検討されなければなりません。ルールセット定義ビューを定義するルールセット定義ビュー(Rulcset Dennition Ⅵew)は、モデルがフレームヮークと一貫性をもつことを保証するため、モデルに適用するルールを特定し定義します。ルールは、主にオントロジー定義ビューとビューポイント関係ビューにもとづいています。いずれの場合も、存在する主要な関係性と多重度を特定することでルールが定義されます。●ビューポイント定義ビュー上のビューポイント間●オントロジー定義ビュー上のオントロジー要素間いくつかのルールの例を示します。次のダイアグラムを見てください。図3.24 ルールセット定義ビューの例図3.24は、SysMLのブロック定義図を使用し、ルールセット定義ビューの例を示しています。図3.24のそれぞれのプロックは、オントロジー定義ビューまたはビューポイント関係ビューのいずれかから派生したルールです。これらのルールは以下のように定義されています。●ルール1:それぞれの構造分解ビューには、少なくとも1つのポート特定ビューが存在しなければなりません(For c¨ h Structural Bκ ak“wn Ⅵew,thcrc must exist at least OncPort ldcntincation vicw)図3.22のビューポイント関係ビューから派生したルールです。●ルール2:それぞれのシステムは、合成関連(Compos􈎸on)にて少なくとも1つのサブシステムから構成されなければなりません(Each systcm must bc made up Of atleast onesubsystem via a composition)“rule〉〉RりlelFor edch sttucturol breakdownview, there must exist ot leostone port identificqtion view.“rule〉〉Rule2Eoch system must be made upol at ledst one Subsystem vioq composition.<rulelRule3Eoch system moy be mode upof one or more Subsystems vioan aggregotion./∫フ図3.6のオントロジー定義ビューから派生したルールです。●ルール3:それぞれのシステムは、集約関連(Aggregation)にて少なくとも1つのサブシステムから構成されなければなりません(Each System may be made up of onc or moКSubsystems via an aggregation)図3.6のオントロジー定義ビューから派生したルールです。他にもルールを定義することができますが、すべての関係性がルールになるわけではありません。どれをルールとするかはモデラーの判断次第です。まとめシステムとそのインタフェースの概念について詳細に検討しました。抽象度および階層間の相互作用、利害関係者の存在など、システムに関連するさまざまな概念をオントロジー上で定義しました。異なる要素間の相互作用が発生する場合、インタフェースを特定することができます。インタフェースは、サービス型またはフロー型という異なる型で定義され、それぞれフローまたはサービスといったプロパティが定義されました。そして、あらゆるインタフェースのさまざまな側面を表現可能な標準的なビューを記述することで、これらのインタフェースをモデリンググする方法を示しました。最後に、これらのビューはすべて、アーキテクチャフレームワークのためのフレームヮーク(Framework for Architecture Framcworks:FAF)にて全体的なフレームワーク定義の一部として取り込まれました。このフレームヮーク自体が、モデルを記述するために使用される多くのビューから構成されています。成功するシステムを開発するためには、システムの基本的な構造を理解することが不可欠です。もし、システムが理解されなければ、決して成功したとは言えません。異なるシステム要素間の相互作用を理解することは、システムの複雑性を管理する上で非常に重要です。これは効果的なインタフェースのモデリンググで達成されます。したがって、本章で紹介したスキルは、システムズエンジニアリングに不可欠です。最終的にシステムの提供が成功するかどうかは、そのシステムがオリジナルのユーズを満たすかどうかにかかっています。これについては次章で紹介します。/びθ
# 第3章 システムとインタフェース

演習問題1。本章で説明したオントロジーにもとづいて、組織内のシステムの一部の構造分解ビューを作成してください。1つのシステムを選択し、その主要なサブシステムを特定してください。2.1.の回答をもとに、合成関連(COmpos􈎹on)と集約関連(AggregatiOn)の観点から、異なる抽象度間の関係性を検討してください。また、関連(Association)に関して、それぞれの抽象度上の関係性、そしてインタフェースの存在する場所を検討してください。3.インタフェース特定ビュー、ポート定義ビュー、フロー定義ビュー、インタフェース接続ビュー、インタフェース振る舞いビューを作成し、あなたのビュー上にあるサブシステム間に存在する少なくとも1つのインタフェースを特定してください。そして説明を記述してください。4。これまでの回答をもとに、あなたのシステムの構成を定義してください。5.図3.22のビューポイント関係図から任意のビューポイントを選択し、テキストによるビューポイントコンテキストビュー、ブロック定義図によるビューポイント定義ビューを作成してください。参三茎􈎹● (Holt&Perry 2019)Holt,J.D.and Pcry,S.A.(2019)SysM:L for Systeins Engineering― aModel― Based Approach,′ rhird edition.IE′ I｀ Publishing,Stcvenage,uIく,2019/び/
# 第3章 システムとインタフェース

システムの境界の外部に存在するものです。イネーブリングシステムは特殊な種類の利害関係者とみなすこともできます。●利害関係者の関心事への関連付け(Stakeholder concern map)アーキテクチャビューをオリジナルのコンテキストに関連付けます。コンテキストは多くの利害関係者の関心事から構成されます。′2フ●システム要素とインタフェース(System element and interace)本章の設計ビューと第3章「システムとインタフェース」の両方でカバーされます。● トレーサビリティ(Traceab􈎹 ty)トレーサビリティはシステムズエンジニアリングにとって重要なテーマですが、MBSEアプローチを適用する場合、すべてのトレーサビリティは暗黙的に実現されています。オントロジーとビューポイントの定義を通して作成されたフレームヮークにより、 トレーサビリティが成立するためです。プロセスで特定されたアクティビティはモデリンググのアクティビティに関連付けられます。以下を見てください。●アーキテクチャ候補のアセスメント(Assess architecture candidateso)さまざまなアーキテクチャの候補とそれに関連するビューを取り上げ、制約を含む基本的なニーズヘの適合性評価に関係します。その結果、望ましい解決策がアーキテクチャ候補として選択されます。●アーキテクチャビューポイントの策定(Develop architecture viewpointso)アーキテクチャフレームワークの定義が十分であるかを確認することに関係します。●候補となるアーキテクチャのモデルとビューを策定(Develop models and views ofCandidate arChiteCtureS())アーキテクチャフレームヮークにもとづくアーキテクチャビューの作成に関係します。ここでは、モデル自体とそれに関連するビューが作成されます。●選択したアーキテクチャの管理(Manage the selected architectureo)プロジェクトが進むにつれ、アーキテクチャを発展させるようなプロセスを確保することに関係します。これらのプロセスは、アーキテクチャのガバナンス、アーキテクチャ戦略の開発、成果の保証に関係します。●アーキテクチャ定義の準備(Prepare for architecture definitionO)アーキテクチャのためのオリジナルのコンテキストと、それがどのように評価され定義されるかを保証します。また、イネープリングシステムを含む利害関係者を十分に理解したうえでアーキテクチャを開発できるようにすること、使用する固有のツールや表記法を特定することも含まれます。●アーキテクチャ設計への関係づけ(Relate the architecture to the designo)設計に関係したアーキテクチャのトレーサビリティに関係しています。繰り返しになりますが、すべてのトレーサビリティのパスはフレームヮークにて定義されます。ノノθlfiualEad0nPrcca63 $€tIF蟻壼壽wo由Syatom Modo: Notat〕on`0わヽtFaむ麟deineS t縫麒『懸「輸銃。レく徹腱壺●癬いow,0籍t ⅥOw Dia撃.4麟1=.まく1.ド1dBscribes he■.「1is msietent with
# 第3章 システムとインタフェース

することがあると説明しました。本章のオントロジーの例では、論理、機能、物理の3つの種類があります。機能システム要素は論理システム要素を満たし、物理システム要素は機能システム要素を実現するということを確認しました。また、ベストプラクティスの重要性についても説明し、ISO/1EC/1EEE 15288の固有のプロセスを検討し、モデリンググビューをそのアクティビテイおよび成果に直接関連付けることで、ビューとの関連付けを実施しました。最後に、これらのビューを「アーキテクチャフレームヮークのためのフレームヮーク(Framework lor Architccture Framcworks:FAF)」の全体的なフレームワーク定義の一部として取り込みました。「アーキテクチャフレームヮークのためのフレームヮーク(Framcwork brArchitccturc Framcworks:FAF)」は、モデリンググをするための多くのビューから構成されています。ノイイ