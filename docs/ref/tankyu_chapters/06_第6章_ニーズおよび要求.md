
# 第6章 ニーズおよび要求

ニーズおよび要求求MBSEに関する最も重要な技法の1つである、ニーズ(Necds)および要求(Rcqu“mcnt)のモデリンググを紹介します。ニーズを理解することは、システムの用途、性能、機能、形式、意図など、システムのあらゆる側面の定義となるため、システムの成功にとって必要不可欠です。ニーズを理解しなければ、納品されたシステムが目的に合致しているかどうか判断することはできません。ニーズこそがシステムの目的を説明するものであり、ニーズを理解していないということは目的を理解していないということと同義です。したがって、すべてのニーズが明確に定義されていること、そしてそのニーズがシステムのすべての利害関係者にて十分に理解されていることが非常に重要です。なぜなら、さまざまな利害関係者がさまざまな方法でニーズを解釈する可能性があるためです。さらに、コンテキストという最も重要な側面を本章で詳しく説明します。コンテキストが明確に定義されていなければ、ニーズが真に理解されて受け入れられることはありません。本章の内容は以下の通りです。●ニーズおよび要求求の導入●さまざまなSysMLのダイアグラムを使用したニーズの視覚化●フレームワークの定義まず、ニーズおよび要求求に関する基本的な概念について説明します。―ズおよ求の導入ニーズという重要な概念を紹介し、要求(Requれmcnt)、能力(Capability)、日標(Goal)など、さまざまな種類のニーズが存在することを説明します。また、用語の正確な意味を定義することの重要性を説明します。さらに、これまで本書を通して開発されてきたMBSEオントロジーについて、これらの新しい概念を導入するために拡張します。まず、ニーズとは何かを確認しましょう。2イノニーズを定義するシステムズエンジニアリングに関連する最も重要な概念の1つがニーズ(Need)です。次のダイアグラムを見てください。describes the purpose of F1¨* 1(ontology elementr>System<ontology element)Need図6.1 基本的なニーズを示すオントロジー定義ビュー図6.1は、SysMLのブロック定義図を使用し、ニーズの概念とシステムとの関係性を含むオントロジー定義ビューを示しています。図6.1は、1つ以上のニーズ(Nccd)が、1つ以上のシステム(System)の目的を説明していることを示しています。ニーズが重要であるのには、いくつかの理由があります。以下を見てください。●システムの望ましい特徴を宣言します。●システムとして何を提供すべきかについて、顧客と供給者という利害関係者の役割間での合意を得ます。●システムが顧客に受け入れられるための手段です。すなわち、合意されたニーズのすべてが満たされることを証明することで、初めてシステムは顧客に受け入れられます。
# 第6章 ニーズおよび要求

ドメインに応じて、さまざまな種類のニーズがあると考えられます。次のダイアグラムを見てください。(ontology element)Need “ontology elerneno,Systern(ontology element,Requirement(ontology element)Goaldelivers F1_ホ(ontology elemenD) meets I'Capabilitydescribes the purpose of )1_*1¨ホ1¨*図6.2 ニーズの種類を示すオントロジー定義ビュー図6.2は、SysMLのブロック定義図を使用し、ニーズの基本的な概念を示しています。図6.2には3種類のニーズがあります。以下を見てください。●要求(Requirement)システムの目的を説明することに貢献し、1つ以上の能力(Capあility)を提供します。要求はシステムの固有のユーズを説明し、システム、サブシステムなど、異なるレベルのシステム要素に適用されることがあります(図6.1には示されていないので注意してください)。●育旨力(Capabi‖ ty)1つ以上の要求(RcquiК mcnt)にて提供され、1つ以上の目標(Goal)を満たすシステムの目的を説明することに貢献します。●目1票(Goal)1つ以上の能力(CTttlity)にて満たされるシステムの目的を記述することに貢献します。このような種類のニーズは、提供されるべきシステム固有の機能を記述するため、機能的なニーズとよく呼ばれます。本書では、この用語をあえて使用せず、オントロジー定義l A dclivcrs B:AはBを提供するA meets B:AはBを満たす2イ∫1ビューで定義した用語のみを使用します。この時点では、ニーズそのものに関しては説明しません。これに関しては、ニーズ記述およびユースケースという2つの方法を使用しながら、次節にて説明します。その際、これらのさまざまな種類のニーズの例をいくつか紹介します。図6.2で紹介した3種類のニーズはあくまで例であり、ニーズの紹介として提示したものです。自分自身の目的に合ったニーズの種類を定義して構いません。また、3種類すべてに当てはまる別のニーズが存在します。これに関しては、この時点で説明しなければなりません。次のダイアグラムを見てください。limits the realization of >1*1_1■ 1(ontology element)constraintdescribes the ofレ1.(ontology element,System(ontology elementDNeed(ontology element)Requirement(ontology element,Goaldescribes need for >1*《くOntologV elernent" describes need for I'Capabl:itV図6.3 制約を示すオントロジー定義ビュー図6.3は、SysMLのブロック定義図を使用し、制約(Constraint)の概念を追加しています。制約(Constraint)は特殊なニーズですが、図6.2で紹介した3種類のニーズと並列に位置します。モデリンググの細かい点ではありますが、これは重要なことです。図6.3のように2つの別々の特化(Spccialization)が使用される場合、実はそれらはまったく別の種類の特化(Specialization)とみなされます。これにより、以下の3つの状況が考えられます。●ニーズは要求(RcquiК mcnt)の一種であり、かつ制約(Cons"aint)の一種である場合2イσ
# 第6章 ニーズおよび要求

があります。●ニーズは能力(Capあility)の一種であり、かつ制約(Constraint)の一種である場合があります。●ニーズは目標(Goal)の一種であり、かつ制約(Constraint)の一種である場合があります。これは非常に強力なモデリンググの仕組みであり、非常に柔軟にSysMLの特化(Specialization)を定義することができます。1つ以上の制約が、何らかの方法でシステムの実現を制限します。ニーズはシステムの望ましい特徴を説明するのに対し、制約はニーズでありながらニーズの実現方法を制限します。制約はしばしば非機能要求(Non― functional Rcquircment)と呼ばれます。本書ではあえてこの用語を使用せず、オントロジー定義ビューで定義している用語のみを使用します。標準的なニーズに比べ、制約を満たすことが難しい場合が多くあります。また、多くの場合、オリジナルのニーズをすべて満たすシステムを開発したとしても、制約を満たさなければシステムを展開することはできません。制約にはさまざまな種類があります。以下を見てください。●品質制率句(Quanty Constraint)特定の標準を満たすことを意味します。たとえば、ヨーロッパではすべての自動車が「IS0 26262自動車―機能安全(IS0 26262:Road vehiclcs― Functiond safety)」の基本要件を満たす必要があります。これを満たさなければ、公道での自動車の使用は許可されません。●環境制糸勺(Environmental Constraint)システムの排出量を制限することを意味します。たとえば、自動車はガソリンエンジンまたはディーゼルエンジンから多くの排出ガスを排出する可能性があるため、内燃機関ではなく電気モーターを使用するように制限されることがあります。●性育論1率勺(Performance Constraint)システムに関して効率的な方法を特定することを意味します。たとえば、給油中または充電中に自動車を移動する場合を考慮すると、移動可能な走行距離を事前定義する必要があります。こちらの走行距離を確保しなければならないという制約がある場合、そのパラメーターに応じてモーターの出力を可能な値よりも低く抑えなければならないことがあります。●実装の制約(lmplementation Constraint)システムの構築において固有の材料を使用すること、または固有の材料の使用を禁止2イアすることです。たとえば、自動車の回路基板の組立てにおいて、一部のはんだに鉛が含まれているため、ある特定のはんだしか使用できないことがあります。これは制約の網羅的なリストを意図したものではありませんが、システムの実現を何らかの形で制限する多くの制約を示しています。本章の後半で説明しますが、制約は他のニーズと関連していなければなりません。すなわち、既存のニーズを制約するものでなければなりません。二一ズを記述するニーズと制約(それ自体は特殊なニーズ)は両方とも概念であるため、何らかの方法で記述されなければなりません。これを実現する方法が、ニーズ記述、そしてニーズに対するユースケース定義です。まずはニーズ記述(Need Dcscmption)を紹介します。次のダイアグラムを見てください。1…ネ1.1.*1_ホ1ｃｒｉ ▼(1_摯(ontology element)Need Description(ontology elemenD)Rule(ontology element)Need(ontology element)Source Element(ontology element))Requlrement〈くontology element〉〉Goaldescribes need for )'1., *describes need for ) (ontology element))Capability図6.4 ニーズ記述を示すオントロジー定義ビュー図6.4は、SysMLのプロック定義図を使用し、オントロジー定義ビューを拡張することで3つの新しい概念を追加しています。以下を見てください。ｎス）″●二―ズ記述(Need Descrlption)個々のユーズを説明するテキストベースの特徴を提供します。これらの特徴は名前、説明、識別子、優先度などの属性の一覧であり、それぞれのニーズ記述に対して定義する必要があります。●ソース要素(Source E!ement)ニーズの起源への参照を提供します。すべてのニーズには起源があり、ソース要素はニーズの正当なソースを提供します。●ルール(Rule)ニーズ記述の定義方法を制限します。たとえば、ニーズ記述に「～するべきである(should)」「～である可能性がある(could)」「妥当である(reasonあle)」などの単語の使用を禁止している場合があります。ニーズ記述は、ニーズの集合を明らかにするという点で重要です。しかし、テキストベースでニーズを記述する場合、ニーズ記述のコンテキストという大きな落とし穴にしばしば直面します。多くの場合、ニーズ記述がどのようなコンテキスト、あるいはどのような観点で書かれたものかを明示的に確認することは困難です。1つのニーズ記述に対して、さまざまな利害関係者が異なる解釈をし、その違いが明らかにならないままになることがよくあります。これを解決するための重要な方法が、ユースケースを使用したニーズ記述です。次のダイアグラムを見てください。(ontology element,Rule Need De■ ri"on(ontology element,Source Eloment{ohtolo8y element},Need(ontology element)lJse Caie(ontology elefrenb)Requiremnt(ontology elementD6Gl〈くontologV elemenO)Capab`“ty(ontotogy elemenD)Conten“ｃｒ ｉＶ● describes1'図6.5 ユースケースを不すオントロジー定義ビュー図6.5は、SysMLのブロック定義図を使用し、オントロジー定義ビューをさらに拡張することで2つの新しい概念を追加しています。次のページを見てください。2イフ
# 第6章 ニーズおよび要求

1-.rdescribes need for>●ユースケース(Use Case)コンテキストベースのニーズの記述を提供します。選択されたコンテキストにもとづき、コンテキストがある固有のニーズの解釈を完全に変更させる可能性があります。●コンテキスト(Context)ユースケースを定義する際の観点を記述します。どちらもニーズを記述するものであるため、ニーズ記述(Need Desc􈎸ption)とユースケース(Usc Case)は混同されがちです。この2つの違いは、ユースケースが固有のコンテキストを経由してニーズを明確に記述するのに対し、ニーズ記述はそうではないという点です。以下の理由により、これらはどちらも重要です。●ニーズ記述は、システムを提供するプロジェクトの契約書として使用されることがよくあります。●ニーズ記述は、ニーズのエンジニアリング、すなわちニーズを理解するためではなく、ニーズを管理するために使用されることがよくあります。●ユースケースはコンテキストを提供します。その結果、1つのニーズに対するさまざまな解釈を正しく理解することができます。したがって、1つのニーズに対して1つのニーズ記述をもち、その1つのニーズが複数の解釈をもち、そしてそれが複数のユースケースにてモデルに取り込まれることになります。ニーズとユースケースを妥当性確認する1つのニーズが複数のユースケースという形で複数の解釈をもつ場合、ニーズの妥当性確認の方法も複数の解釈に対して実施されます。このような複数の妥当性確認は、シナリオ(Scenano)を使用してモデリンググします。次のダイアグラムを見てください。2∫θ
# 第6章 ニーズおよび要求

ｒ ｉｂＶ1_ { describes 1.valttes1'(ontology element) (ontology elementDRul6(ontology @lement)Ne€d D.*rlpdon(ontology element,Sourc€ Eldmaht(ontology element)Itleed(ontolcgy element,U5e care(ontology element,Requirement《o■ology element"Co8:(ontolosy elefieht)saenarlodescribes need for> (ontology element,Cqprbllity図6.6 シナリオを示すオントロジー定義ビュー図6.6は、SysMLのプロック定義図を使用し、シナリオ(SCenano)がユースケースを通してニーズの妥当性評価の仕組みを提供することを示しています。システム開発を成功させるためには、それぞれのニーズが満たされることの実証が重要です。それぞれのニーズは複数のユースケースをもつ可能性があるため、それぞれのユースケースが満たされることを実証できなければなりません。それには、それぞれのユースケースの妥当性確認をするためのシナリオを数多く定義する必要があります。シナリオは以下の2種類の方法で実現可能です。●運用シナリオ(Operational Scenario)ある固有の成果をもたらす一連のイベントまたはアクションを示します。運用シナリオは連続的な性質をもつ場合が多いです。●パフォーマンスシナリオ(Performance Scenario)システムのパラメーターを変更し、ある固有の成果を満たすことを実証します。パフオーマンスシナリオは数学的な性質をもつ場合が多いです。本節で紹介した概念は、ニーズのオントロジー定義ビューにて提供されました。このニーズオントロジーにもとづくビューの実現について、次節で詳しく説明します。2∫ /need for >SysMLダイアグラムにて二一ズを視覚化する前節では、ニーズに関する概念をニーズのオントロジーとして定義しました。本節では、これらの概念をより詳細に説明し、いくつかの異なるビューを使用することでニーズがど｀のように実現されるかを説明します。それぞれのビューはSySMLの表記法を使用して視覚化されます。ソー丞璽素を視覚化するソース要素を定義することの重要性について説明し、ソース要素を視覚化するために使用されるソース要素ビューを紹介します。ソース要素を特定する必要性に関して、以下の5つの基本的な理由があります。●システムのために定義されたすべてのニーズの起源を特定するためこの理由は見落とされがちであり、完全に無視されたりすることも多いのです。しかし、これは多くの理由から重要です。●すべてのニーズの起源を実証するためそれぞれのニーズの起源を特定できることが重要です。ソース情報はその起源への実際の参照を含む必要があります。なぜなら、ニーズが何らかの形で照会された場合、ソース情報を特定して確認することができなければならないためです。●ニーズをもつ利害関係者を特定するためニーズが利害関係者まで追跡できない場合、それをニーズと認めることはできません。利害関係者はシステムに関心をもつ役割と定義されており、すべてのニーズは一人以上の利害関係者まで追跡できる必要があります。●不特定のニーズを防く゛ためあるニーズがプロジエクトのある作業者からもち込まれ、そのニーズがある特定の利害関係者からは正式に認められていないという問題がよくあります。その結果、不必要で余計なニーズが発生したり、システムにとって不利益となるニーズが発生したりします。●何が正当なソース要素であるかを特定するためシステムの性質と重要度に応じて、何が正当なソース要素で何が正当なソース要素でないかを特定することが重要です。したがって、考慮しなければならないオントロジー要素はソース要素ですが、ソース要素の種類も明示的に示す必要があります。次のダイアグラムを見てください。2∫2
# 第6章 ニーズおよび要求

(0rtology element,Source Ehment(0ntology elernent,Marketing Material “OntO103V element"Standard(ootology elementDPublication(ontology element,Customer RequestDateNarneVersl● nAuthOrDateiSSNTitleCustomer nameCustomer numberR€quest identifierR€quest statusDatePublisherstandard organisationTitleV€rsion図6.7 ソース要素の種類を示す拡張オントロジー定義ビュー図6.7は、SysMLの特化(Spccialization)を使用し、新たに4種類のソース要素を追加しています。以下を見てください。●マーケティング資料(Marketing Material)マーケティング担当者が使用する、開発中の最終製品を示す情報です。たとえば自動車業界の場合、潜在顧客にとって望ましいと思われる新車の特徴や、開発中の新車システムに導入しなければならない機能を紹介する営業資料などです。●標準(Standard)たとえば自動車に関連するベストプラクテイスの参考文献を示す情報です。ISO26262などの安全標準、新車の宣伝活動の一環として使用されるユーロNCAP(Europcan Ncw Car Asscssment Programme:ENCAP)の評価基準などです。これらの標準は、システムまたはそのシステムを開発するために実施されているプロジェクトのさまざまな側面をカバーします。●出版物(Pub‖ cation)本書のような書籍や科学論文などもニーズを生み出す可能性があります。たとえば、MBSEのような特定の分野におけるベストプラクテイスの業界標準として書籍が使用されることがあります。●顧、7茎:要求 (Customer Request)既存の顧客からの固有の要求が生じることがあります。たとえば、古いバージョンの自動車を使用している顧客は全員が同じような不満をもつ可能性があり、新バージョンの自動車に新たなニーズを導入することで問題を解決できるかもしれません。新しい種類のそれぞれのソース要素には、固有のソース要素を参照できるように、関連するいくつかのプロパティがあることに注意してください。2∫ノ正当なソース要素を特定するのと同様に、正当でないソース要素も特定する必要があります。次のダイアグラムを見てください。(ontology eiement)Source Element“ontology elernent》Forbidden SourccElement(ontology elementtLegal Source Element(ontology element,Customer Request(ontology element>Marftetin8 Material(ontology elementDStendard(ontology element)Publicatiqn(ontology element)WebsiteDateNameVersionCustomer nameCustgmer numberRequest identifierRequest statusAuth。「IS8NTitleDatePublisherStandard organisationTitleVersion図6.8 正当なソース要素および禁止されているソース情報を示すオントロジー定義ビュー図6.8は、SysMLの特化(Spccialization)を使用し、拡張オントロジー定義をさらに拡張しています。図6。7ではソース要素の種類を示しましたが、図6.8は新たなレベルの分類を導入しています。以下を見てください。●正当なソース要素(Legal Source Element)以前に確認したソース要素と同じです。ただし今回は、これらのソース要素が正当であることが明示的に示され、モデル内での使用が許可されています。●禁止されているソース要素(Forbidden Source Element)ウェブサイト(Wcbsitc)という新たなソース要素が追加されました。このソース要素は不正であるとみなされます。禁止されたソース要素に対してプロパティを追加する必要はありません。なぜなら、これらはモデルに追加されることはなく、明示的な仕様が不要であるためです。これにより、ソース要素として許可されるもの、許可されないものを正確に記述することができました。正当なソース要素の場合、そのソース要素を正確に参照するため、プロパティの特定が必要となります。25イ
# 第6章 ニーズおよび要求

この拡張されたオントロジーは、ソース要素ビューの基礎として使用することができます。次のダイアグラムを見てください。(marketing material)Car BrochureDate = December 2020Name = New Car Models 2021Version = 1.1(standard))Safety StandardDate = November 201LPublisher = ISOStandard organisation = ISOTitle = ISO 26262;2011, ...Version = 1(customer request))Request #1Customer name = Company XCustomer number =Xl.Request identifier = CR:12.2Request status = open< publication >Don't Panic!Author=」on Holt&Sirno…Date=November 20171S3N=978-0‐ 9934857‐ 1-8Title=Donit panicl Ab..・図6.9 ソース要素ビューの例図6.9のそれぞれのブロックは1つのソース要素を示しています。図6.7の拡張オントロジー定義ビューから取得したステレオタイプを使用しており、これらはすべてソース要素の種類のいずれかです。ソース要素を厳密に特定するため、それぞれのソース要素のプロパティに値が設定されていることに注目してください。ここでは、SysMLのブロック定義図を使用してソース要素ビューを視覚化していますが、テキストまたは単純な表にて簡単に視覚化することもできます。しかし、ブロック定義図を使用することで、テキストだけを使用するよりも以下のような多くの利点があります。●ビューはモデルの一部でなければなりません
# 第6章 ニーズおよび要求

(ontology element))Need DescriptionDescriptionldentifierNameOriginPriorityValidation図6.10 ニーズ記述に特化したオントロジー定義ビュー図6.10は、オントロジー定義ビューにて、あるオントロジー要素を示しています。このオントロジー要素は、図6.4で示したニーズ記述(Need Description)です。しかし、今回はいくつかのプロパティが特定されています。以下を見てください。●言己述 (Description)平易な英語でニーズの詳細を説明するテキストベースの説明文です。●識男ll子‐(ldenmer)トレーサビリテイのために使用可能なニーズ記述への一意の参照を提供します。●名前(Name)ニーズの簡単な説明として使用可能なハイレベルのラベルを提供します。●起源(Origin)オリジナルのニーズを特定する責任をもつ利害関係者を直接参照します。●優先度(Priority)ニーズの重要度を示します。たとえば、「必須(Mandatory)」、「推奨(Dcsirめle)」、「任意(Optional)」のように設定することができます。●妥当性確認(Vandatlon)ニーズが満たされていることを実証するために使用するシナリオの数を示します。シナリオについては本章で後述します。特定されたそれぞれのニーズには、それに関連する1つのニーズ記述があります。これらはSysMLの要求図を使用してモデリンググすることができます。SysMLの要求図は、本書でこれまで詳しく説明されていない新しいダイアグラムです。要求図は、SysMLのブロック定義図のバリエーションであり、2つの基本要素から構成されています。●要求 (Requirement)く<requircment>>とステレオタイプ化された特殊なブロックです。一意の識別子を提供する「id」と、テキストの説明を定義可能な「text」という2つの定義済みプロパティ2∫ /をもちます。●関連 (Relationship)要求ブロック同士を関連付けます。SysMLの要求図は、ニーズ記述を視覚化するために使用することができます。次のダイアグラムを見てください。( requirement)Access carDescription =The car will alldentifier = REQ#O21Name = Access carOrigin = DriverPrioritY = MandatorYValidation = SC#45, SC#46図6.11 あるニーズ記述のためのニーズ記述ビューの例図6。11は、SysMLの要求図を使用し、あるニーズ記述に焦点を当てて視覚化しています。この例では、「自動車に乗り込む(Acccss ca」というニーズ記述がSysMLの要求ブロックで表現されています。ニーズ記述のプロパテイに値が設定されていることに注意してください。図6.11は、プロジェクト固有のニーズに合わせて、基本的なSysMLの言語を調整しなければならない場合があることも示しています。SysMLの要求ブロックには定義済みのプロパテイが2つしかなく、ニーズ記述のプロパテイとしてはまったく足りません。しかし、これはSysMLの欠陥ではなく意図的なものです。「id」と「teXt」という数少ないプロパティのみを定義することで、モデラーが自身の目的に合ったプロパティを独自に定義できるようにしています。この例では、図6.10でオントロジーとして定義され、その中で表示されているプロパテイが使用されています。実際のプロジェクトでは、複数のニーズ記述とそれらの間の関係を示すことが一般的です。そのため、ある1つのニーズ記述のみを含むニーズ記述ビューは、ほぼ存在しないでしょう。次のダイアグラムを見てください。2∫∂(need description, lI;3Travel from A to B(need descripton) mDrive car(need descriptr'on)Access car“need descrip● on》 日11380 safeMeet safety stendards(need description)
# 第6章 ニーズおよび要求

図6.12 複数のニーズ記述を示すニーズ記述ビューの例図6.12は、SysMLの要求図を使用し、複数のユーズ記述を示すニーズ記述ビューを示しています。この例では、2つの上位レベルのニーズ記述と、それらに関連する下位レベルのニーズ記述が示されています。この分解は、丸十字の記号を使用して表現されます。これは、SysMLの要求図で使用される多くの関連(Rel􈎹 onship)のうちの1つに過ぎません。この入れ子構造により、ニーズ記述を下位のユーズ記述に分解することができます。要求図で使用されるもう1つの便利な関連(Rcl􈎹 onship)は、く<trace>>で示される追跡関連(Tracc)です。次のダイアグラムを見てください。図6.13 トレーサビリティを示すニーズ記述ビュー図6.13は、SysMLの要求図を使用し、 トレーサビリティを示すニーズ記述ビューを示しています。この例では、ニーズ記述とソース要素の間に明示的なトレーサビリティを示すため、追跡関連(Tracc)が使用されています。この場合、ソース要素の2つの特殊化(Spccialization)である<くstandttd>>とくくcusわmer request>>があります。 トレーサビリティを示す機能は非常に強力ですが、表示されるトレーサビリテイのパスがオントロジーと一貫性をもつことが不可欠です。この場合、追跡関連(Tracc)は、ニーズ記述とソース要素の間の明示的sattty standard.<customer request,Request Bl(need description) infravel from A to B《neSIl:::雪F°n》圃(need descriptionD [f]Accest Ca.“n∝糧e露.ぽ°n》圏《need deSCttp● On》 =]Provide air ba鮮 ~~(trace,2∫フ(need description)Provide air bagsなトレーサビリティを示します。これは、図6。4のオントロジーと一致しており、ニーズ記述からニーズ、そしてソース要素へのトレーサビリティのパスを示しています。もし、このトレーサビリティのパスがオントロジー上に存在しなければ、このビュー上の追跡関連(Tracc)は不正確であり、モデルを破壊してしまうでしょう。要素と関連の両方を含むビュー上のすべてのものは、オントロジーからのオントロジー要素とオントロジー関連の直接のインスタンスでなければなりません。要求図で使用できる他の関連(Rclationship)もあります。以下を見てください。●複製(Copy)SysMLの要求が、他の要求の正確かつ直接的な複製であることを示します。これは、共通点のないソース要素にて、ある要求の記述の複製が複数作成される場合に役に立ちます。●導出(De‖ve)既存のSysMLの要求の結果として、以前には存在しなかった別のSysMLの要求が直接作成された場合に使用します。●詳細化(Refine)既存のSysMLの要求にもとづき、SysMLの要求を変更または修正する場合に使用します。たとえば、文言が修正された場合、ユースケースのモデリンググの結果として変更される場合などがあります。ユースケースのモデリンググに関しては次節で説明します。●充足(Satisfy)モデルの他の側面をSysMLの要求に関連付け、検証または妥当性確認を示すことができます。SysMLの要求図は、ニーズを理解するためではなく、ニーズを管理するために使用されるということに注意してください。SysMLの要求図は、いくつかの商用の要求管理ツールの標準的なビューにもとづいています。したがって、標準的な関連(Rehionship)の名前に関しては、一部の読者にはなじみがあるかもしれません。ここに大きな潜在的な危険性があります。すなわち、多くの人々がテキストベースのニーズであるニーズ記述ビューを作成し、それがニーズのエンジニアリングであると誤解してしまうことです。この考えは正しくありません。ニーズ記述ビューだけで構成されたニーズにはまったく信頼性がありません。ニーズ記述ビューは重要なビューですが、それは単に1つのビューに過ぎません。ニーズを完全に、徹底的に、厳密に理解するためには、そこで提示されるビューの完全な集合2びθ
# 第6章 ニーズおよび要求

を検討することが重要です。他のビューで考慮しなければならない非常に重要な側面は、コンテキストという概念です。コンテキストは、テキストベースの記述だけを考慮した場合、しばしば無視されたり、完全に見落とされたりします。この重要な概念であるコンテキストとモデリンググ技法について次節で説明します。コンテキスト定義を_視覚化する次に説明するビューは、コンテキスト定義ビュー(Context Dcnnition Ⅵew)です。ニーズをモデリンググする際、その根底にあるニーズを理解するためには、コンテキストの特定と定義が不可欠です。それぞれのコンテキストは、ニーズを検討するための観点を提供します。さまざまなコンテキストからニーズを見ることで、ニーズに対するさまざまな解釈を理解することができます。これはニーズを正しく設計するために非常に重要なことです。コンテキストは、多くの異なるソースにもとづく可能性があります。本節では、利害関係者コンテキスト(Stakeholdcr Context)およびシステムコンテキスト(Systcm Contcxt)について説明します。システムに存在するさまざまな利害関係者にもとづき、多くの異なるコンテキストが特定される可能性があります。利害関係者は非常に一般的なコンテキストのソースであり、ニーズモデリンググを厳密に実施するための不可欠な要素です。システムに存在するそれぞれの利害関係者はある1つのニーズを見ていますが、潜在的にはそのニーズをさまざまな方法で解釈する可能性があります。これらのさまざまな解釈はユースケースとして知られており、次節で詳しく説明します。重要なことは、どのような利害関係者が存在するかを適切に把握することです。すでに本書で説明した通り、利害関係者の特定はシステムズエンジニアリングに不可欠な要素です。次のダイアグラムを見てください。26/(stakeholder role,Cs(stakeholder role,St ldroldor(stakeholder rcleDc[domt(stakehold€r roleDEdemd(stakeholder role)Auppllst(dakeholder role)Drlto,(stakeholder role,CrrOw<stakeholder rolerv€rdo.lffin(stakeholder role)L.rdd Mrlnt mM(stakeholder role,Ibwn6.r<stakeholder role,tothlauoi($akeholder roletSrrr{r8d(stakeholder role,lhaulhetrar(stakeholder role,S.ltnyEtrdnscstakeholder role>e.r lliot(stakehoider role,tu d lrrs図6.14 利害関係者にもとづくコンテキスト定義ビュー図6。14は、SysMLのブロック定義図を使用し、コンテキスト定義ビューを示しています。これは、すでに本書で確認した利害関係者ビューと非常によく似ていますが、ビューの名前が異なります。なぜなら、このビューが必ずしも利害関係者にもとづいているとは限らないためです。たとえば、これがシステム構造にもとづいている場合もあります。その場合、ダイアグラムの見え方が異なります(これについては、次のダイアグラムで検討します)。利害関係者だけでなく、コンテキストの他のソースに焦点を当てることができるため、このダイアグラムをコンテキスト定義ビューと呼びます。利害関係者の分類階層は以前確認したものと同様ですが、今回はより多くの利害関係者をビューに追加しています。このビューには合計で11の利害関係者が示されています。これは、11の異なるコンテキストがあることを意味し、それぞれのニーズの解釈も11通りの可能性があることを意味しています。そのため、ニーズを徹底的に理解するためには、気が遠くなるほど多くの作業が必要になります。しかし、これは、ニーズがいかに複雑であるかを示す非常に良い例であり、モデリンググの必要性を示しています。もし、モデリングが実施されなければ、それぞれのニーズに対するさまざまな解釈が隠れてしまい、このような複雑性がこの時点で考慮されないことになります。この隠された複雑性は、これらのさまざまな解釈が明るみに出るライフサイクルの後半で確実に問題となります。また、ニーズモデリンググでは、利害関係者に関するコンテキストとは別に、システム構造に関するコンテキストも常に作成されるべきです。次のダイアグラムを見てください。262<ontology element,Stakeholder(ontology element,SYstem1¨ ホ♂マ驚‥‥ｌ<ontology element,SubsystemｎｔＴｌ．１１・(ontology element>Assembly′ヽ１１‥１１１<ontology element>rComponenthas an lnterest in >1¨キ
# 第6章 ニーズおよび要求

図6.15 システム構造にもとづくコンテキスト定義ビュー図6.15は、このビューが図6.14のビューと同じ種類であることを示していますが、利害関係者ではなくシステム構造に焦点を当てている点が異なります。図6.14ではシステムが1つのプロックとして存在し、利害関係者が詳細に示されていたのに対し、図6.15では利害関係者(Stよcholdcr)が1つのブロックとして存在し、システムが詳細に示されていることに注目してください。利害関係者にもとづくコンテキストを考える場合、利害関係者の種類ごとに独自のコンテキストが生じます。システム構造にもとづくコンテキストを考える場合、システム階層のコンテキストが生じます。これらのコンテキスト定義ビューが定義されたことで、コンテキストそのものを見ることができるようになりました。ここで定義したコンテキストにもとづき、次節ではユースケースのモデリンググを説明します。コンテキストを視覚化する前節では、いくつかのコンテキストを特定しました。本節では、それぞれのコンテキストをどのようにモデリンググするかを説明します。そのために、ユースケースを確認する必要があります。それぞれのニーズに対して、SysMLのユースケース図を使用してユース2びリ0.*ケースをモデリンググします。SysMLのユースケース図に関しては、本書ですでに確認してきました。特に、フレームヮークとビューポイント定義のためにコンテキストを見る際、非常にハイレベルなユースケース図のみを説明しました。本節では、ユースケース図についてより詳しく説明し、すでに登場した自動車の例を使用してさまざまなモデリンググを構築して示します。SysMLのユースケース図はもっとも広く使われているダイアグラムの1つですが、誤用されることが非常に多いダイアグラムの1つです。ユースケース図は単純であることが望ましいのですが、それがユースケース図は簡単に作成できるという誤解を招いています。ユースケース図を正しく作成するためには、多くの努力と構造化された思考が必要になります。そのため、ユースケース図が単純であるからと言って、その作成が簡単であるということはありません。ユースケース図には、主に4つのモデリンググの構成要素があります。以下を見てください。●ユースケース(Use case)SysMLのユースケース(use case)は、オントロジー上で定義された概念的なユースケース(Use Case)を不しています(この2つの用語は同じものであるため、混乱することがあります。大文字始まりのユースケース〈Usc Case〉はオントロジー要素であることを示し、小文字始まりのユースケース〈use case〉はSySMLのモデル要素を示すことに注意してください)。SysMLのユースケース(usc case)は、ユースケース図にて楕円で表現されます。●アクター(Actor)SysMLのアクターは、オントロジー上で定義された利害関係者を示します。SysMLのアクターは、ユースケース図にて棒人間で表現されます。●境界(Boundary)実際のコンテキストを示します。境界は、ユースケースを包含し、外部にアクターをもつ大きな長方形で表現されます。●関係性(Relationship)ユースケース間、およびユースケースとアクター間の関係性を示します。これらは、関係性の性質に応じて、さまざまな線で表現されます。これに関しては、後ほど詳しく説明します。SysMLユースケース図の一般的な使用方法は、ソースとなるニーズをSysMLのユースケースとして把握することです。これ自体は単純な作業で、ソースとなるニーズをSysMLのユースケースになるように楕円で再描画し、SysMLのアクターと結合させるだけです。しかし、完成したユースケースは、以下に示すような不正確なダイアグラムにな2びイ
# 第6章 ニーズおよび要求

りがちです。SysMLのユースケース図はもっとも広く使用されているSysMLのダイアグラムの1つですが、同時に最も誤用されているダイアグラムの1つでもあります。これは、SysMLのユースケースが具体的に何を示すかについて正しく理解されていないことが原因です。図6.16 作成してはいけない不正確なSysMLのユースケース図の例図6.16は、作成してはいけない不正確なSysMLのユースケース図の例を示しています。このダイアグラムが受け入れられない理由は後ほど説明します。図6.16は、初期のニーズ記述をもとに、SysMLのユースケース図にてそれぞれのニーズ記述を作成し直したものです。「安全である(Bc safc)」と「AからBへ移動する(Travelfrom A to B)」という2つのユースケースを確認し、図6.12のニーズ記述と比較してみてください。これらが同一であることは明らかです。すなわち、ここで示したSysMLのユースケースはニーズ記述そのものであり、オントロジー上で定義されたユースケースを示しBe safeBe secureEscape carTravelfЮ m A to BSeat tive peopleBe comfortableManulacturer２人car ThiefPassenger2σ∫異(sbkeいolder ro e,Safety Standerd貴《stattholderVendor Maintenance賽`stakeいolder role)Driver Contextていないことになります。そのため、図6.16は根本的に間違っていると言えます。SysMLとモデリンググの世界で「ユースケース」という同じ用語を使用しているため、話がより複雑になってしまいます。そのため、一度ここで要点を整理します。●それぞれのニーズは、1つのニーズ記述にて示されます。これは、図6.5のオントロジー定義ビューから直接引用したものです。●それぞれのニーズは、コンテキストを介して、1つ以上のユースケース(Use Case)にて示されます。これも図6.5のオントロジー定義ビューから直接引用したものです。したがって、ニーズ記述とユースケース(Use Case)のオントロジー要素の違いは、ユースケース(Use Casc)がコンテキストにもとづいているのに対し、ニーズ記述はコンテキストにもとづいていないという点です。次に、SysMLのユースケース図と関連するSysMLのユースケース(usc case)を考えてみましょう。●それぞれのSysMLのュースヶ―ス(use case)は、ユースケース(Use Case)のオントロジー要素(コンテキストにおけるニーズ記述)を表現する必要があります。●それぞれのSysMLのユースケース(usc casc)は、ニーズ記述のオントロジー要素を直接表現してはいけません。なぜなら、その方法ではコンテキストを定義することができないためです。図6.16の1つ目の問題点は、SysMLのユースケース(usc casc)がニーズ記述を表現しており、ユースケース(Usc Case)を表現していないことです。図6.16の2つ目の問題点は、システムズエンジニアリングとシステム思考の基本に関わる点です。図6.16は、SysMLのユースケース間の関係性をもたず、表示しているビューの複雑性を示せていません。モデリンググの重要な側面は、モデリンググにて複雑性の領域を特定することです。なぜなら、それにより、重要なモデル要素間の関係性を視覚的に示し、見落としを防止することができるためです。これは隠れた複雑性に関係します。SysMLのユースケース図では、ユースケース間の関係性や依存関係を表現することができます。次のダイアグラムを見てください。2び`
# 第6章 ニーズおよび要求

Use Case 1 UI‐ se Case 2Use Case 1《include》<extend><constrain>Use Case 2Use Case 1 Use Case 2Use Case 1 Use Case 2図6.17 SysMLの基本的なユースケース図の関係性図6.17は、SysMLのユースケース図を使用し、SysMLの基本的なユースケース図の関係性を示しています。SysMLのユースケース間で使用できる基本的な4種類の関係性があります。以下を見てください。●包含関連(inc!ude)ステレオタイプくくinclude>>で示される関係性です。ユースケース1がユースケース2を含む(Use Casc l includes Usc Case 2)と読みます。これは、ユースケース1は必ずユースケース2を含むことを意味し、ユースケース1を満たすためにはユースケース2も満たさなければならないことを意味します。これは、2つのSysMLユースケースの間にある必須の依存関係と考えることができます。●拡張関連(Extend)ステレオタイプく<extend>>で示される関係性です。ユースケース2がユースケース1の機能を拡張する(Usc Casc 2 extends thc functiOnality Of usc case l)と読みます。これは状況および固有の条件に応じて、ユースケース1はユースヶ―ス2を含むことがあることを意味し、ユースケース1を満たすためには、ユースケース2を満たすことが必要な場合があることを意味します。これは、2つのSysMLユースケースの間の任意の依存関係と考えることができます。2`/●制約(Constraint)ステレオタイプ<<const􈎹n>>で示される関係性です。ュースケース2がユースケース1を制約する(Usc Case 2 constrains Use Case l)と読みます。 これはユースケース2がユースケース1の実現方法を制限することを意味します。●,凡化 (Genera‖ zation)、 特化 (Specialization)汎化および特化の関係性です。これは、ユースケース2はユースケース1の一種である(Use Casc 2 is a type of Use Casc l)、またはユースケース1はユースケース2の一種をもつ(usc Case l has a typc of Use Case 2)と読みます。これは、特化に関する継承も含め、ブロック定義図の汎化および特化とまったく同じように機能します。これら4つの基本的な関連により、SysMLのユースケース間の依存関係を定義することができ、基礎となるユースケースの理解を深めるための強力な仕組みとして提供されます。アクターとSysMLユースケースの間には別の関係性があり、特定のアクターが特定のSysMLのユースケースに何らかの関心をもっていることを特定することができます。これらの関係性がどのように機能するかを示すため、図6.16に新しいユースケースを追加します。関係性がどのように使われるかに注目してください。次のダイアグラムを見てください。図6.18 運転手のニーズコンテキストビュー2`∂○¬~《“ake品I縫rD6ign En€liner○■ ~∧“iaにholder(!takeholder role,ca lhletVendor Malntdanee○¬ ~∧《stakeholdersafoty En6r6r (stakeholder role,P.a$igcl♀人繊role'Be wlre&aee CarNegatiw~~~1くヽモ,I(■,~~'Ddwr Cohen--i".ril;";-*--(include,Seat tw peod€Dm manu詢
# 第6章 ニーズおよび要求

図6.18は、モデリンググに関して多くの興味深い点があります。まず、ニーズコンテキストビューが1つのコンテキストを示している点です。この場合、コンテキストは運転手(D􈎸ver)の利害関係者の視点にもとづいています。利害関係者にもとづいてコンテキストを記述する場合、コンテキストは、コンテキスト定義ビューに存在する利害関係者の1つにもとづいていなければなりません。コンテキスト定義ビューにて定義された利害関係者は、それぞれ独自のコンテキストをもつ可能性があります。その結果、それぞれの利害関係者のための必要なコンテキストビューが存在することになります。コンテキストの名前、この場合には運転手(Dr􈎺cr)は、大きな四角形で表現されるダイアグラムの境界の内部に書かれています。ユースケース図に境界があるということは、それがコンテキストを表現しているということを示しています。ユースケース図に境界がなく、コンテキストを表現していない場合もあります。このようなユースケース図は、他のユースケース図の上位ユースケースを分解したものになります。このように、コンテキスト自体のユースケース図が必要である場合もありますが、最終的に最上位は、境界にて示されたコンテキストでなければなりません。したがって、境界はコンテキストを示し、その結果、関係する利害関係者はダイアグラム上に表示されません。この例では、ダイアグラム全体が運転手(D􈎸 vcr)の視点またはコンテキストを示しているため、運転手(Dr􈎺 er)の利害関係者をダイアグラム上に表示する必要はありません。境界は、そのコンテキストに関連するSysMLのユースケースを示します。コンテキストに関心をもつアクターは、コンテキストの境界の外部に存在します。利害関係者がコンテキストに関心をもつ場合、その利害関係者はSysMLのアクターとして表現され、アクターを意味する棒人間とそのアクターが関心をもつSysMLのユースケースの間に関係性が直線で示されます。図6.18では、セーフティエンジニア(Safcty Engincer)と「安全である(Be s山)」との間、「ベンダー保守担当(■ndor Maintenancc)」と「安全である(BeSafe)」との間に直線があります。SysMLのユースケース図を読むとき、最上位のSysMLのユースケースを探してみてください。この場合、それは「AからBへ移動する(Travcl from A to B)」が最上位のユースケースです。このユースケースは包合関連(Indude)もち、かつ他の上位のユースケースには含まれていないためです。したがって、図6.18のユースケースは、次のように読むことができます。26フ●「AからBへ移動する(■avelfrom A lo B)」は、「運転する(Dr􈎺 e)」と「自動車に乗り込む(Access car)」を含むステレオタイプ<<inClude>>で示される包含関連(Inclu“)から、「AからBへ移動する(Travel from A to B)」が満たされるためには、それに合まれる2つのユースケースが常に満たされなければなりません。●「AからBへ移動する(■avelfrom A"B)」は、「安全である(Be sa“ )」、「セキユアである(Be secure)」、「5人座らせる(Seat nve people)」、「快適である(Be confortable)」、「効率的である(Be emdent)」にて制約される制約となるユースケースは、「AからBへ移動する(Travcl from A to B)」を実現する方法を制限します。たとえば、車上で乗客が不安定なバランスをとるようなシステムを構築したとしても、「AからBへ移動する(Travcl from A to B)」のユースケースを満たすことはできます。しかし、この場合は「安全である(Be safc)」を満たさないため、結果として「AからBへ移動する(Travcl from A to B)」の実現方法は制限されることになります。●「自動車に乗り込む(Access car)」は、「自動車から逃げる(Escape car)」にて拡張される「自動車から逃げる(Escape c肛)」が常に「自動車に乗り込む(Acccss car)」に含まれるわけではなく、ある条件下で含まれる可能性があることを意味します。この場合、その条件は衝突事故のような緊急事態の発生に関連したものである可能性があります。拡張機能は、理想的な世界では決して満たされる必要のない非典型的な条件に使われることが多いですが、安全のためには考慮する必要があります。●「運転する(Dr􈎺 e)」には、「手動で運転する(Dr􈎺 e manuany)」と「自動で運転する(Dr􈎺 eautonomously)」の二種類があるこの2つの特化(Specialization)は、「運転する(Dnvc)」の下にある3つの包含関連(Include)のユースケースすべてを含みます。また、この2つの特化(Spccialization)の違いは、それらの固有のユースケースに追加される可能性があります。●「運転する(Dr􈎺e)」は、「ルート探索して走行する(Na􈎼 ga")」、「駐車する(Park)」、「適度な速度でスムーズに走行する(Cruise)」を含むステレオタイプ<くinclude>>で示される包含関連(Include)が使用されています。これらの関連性は非常に重要であり、これにより、ユースケースをより完全に理解することができます。関連性の1つを変更するだけで、ダイアグラムの全体的な意味を変えることができます。たとえば、「ルート探索して走行する(Na􈎼 gate)」のユースケースの関係性が包含関連(Includc)ではなく拡張関連(Extcnd)である場合、オリジナルの包含関連(Includc)では必須であった「ルート探索して走行する(Navigatc)」が任意となります。2アθ
# 第6章 ニーズおよび要求

さまざまなコンテキストを探求するニーズ記述とは異なり、ユースケースにはコンテキストがあり、利害関係者の視点によってさまざまな解釈がなされる可能性があります。本節では、この点をより詳細に説明し、これらのさまざまな解釈の例をいくつか示します。例としてユースケース「安全である(Besafc)」を取り上げ、いくつかのコンテキストからその意味を探求します。「安全である(Bcsafe)」は図6.12のニーズ記述で定義されましたが、コンテキストに応じてさまざまな意味をもつ可能性があります。コンテキストを明らかにすることにより、オントロジー上で定義された真のユースケースをモデリンググしたことになります。まずは運転手(D􈏜cr)のコンテキストを説明します。次のダイアグラムを見てください。Be safePrevcnt injrlryPrevent accidentsDriver Context---- (includeD“inCludeン｀ヽLゝ、トSafety Engineer図6.19 運転手のコンテキストから「安全である」に焦点を当てたニーズコンテキストビュー図6.19は、SysMLのユースケース図を使用し、「安全である(Bc safc)」ユースケースに焦点を当てた運転手(D􈏜cr)のコンテキストからのニーズコンテキストビュー(NccdContext Ⅵew)を示しています。「安全である(Be s農)」ユースケースの正確な意味は、ユースケースを追加して「安全である(Be safc)」との関係性を示すことができます。運転手のコンテキストでは、「安全である(Bes畿)」が、「怪我を防ぐ(PrCVCnt injuヮ)」と「事故を防ぐ｀(Prcvcnt accidcnts)」の2つの包含関連(Includc)をもちます。この例に関して、あなた自身を運転手であると想定し、「あなたにとって安全である(Besafe)とは何ですか?」と自間自答してみてください。これに答えることができると、真のユースケース、すなわち運転手(D􈎸 ver)の観点から見た「安全である(Bc safe)」のユースケースの固有の解釈が得られます。2ア/ここでは、セーフティエンジニア(Safcty Enginecr)の利害関係者がコンテキストの境界の外部に存在するSysMLのアクターとして表現されていることに注意してください。これは、セーフティエンジニア(Safety Engineer)のコンテキストを検討する際に重要となります。次に、同じユースケースについて異なるコンテキストから考えてみましょう。次のダイアグラムを見てください。Be safe Meet satetyitandardsrestralntsstandards for Meet standards forlmpactEngineer Contextrole, (constrain) Stenderd図6.2o セーフティエンジニアのコンテキストから「安全である」に焦点を当てたニーズコンテキストビュー図6.20は、セーフティエンジニア(Saby Engineer)のコンテキストから「安全である(Be safe)」のユースケースを示しています。これを理解するためには、運転手のコンテキストと同様のアプローチをとる必要があります。 すなわち、あなた自身をセーフテイエンジエアだと想定し、「あなたにとって安全である(Be safe)とは何ですか?」と自間自答してみてください。このコンテキストでは、「安全である(Be safe)」とは安全標準を満たすことであるという答えが示されており、それが「安全に関する標準を遵守する(Mcctsafety standads)」という制約として表現されています。さらに、2つの新しいユースケースを導入することにより、「拘束性能に関する標準を遵守する(Meet standards for res"aints)」と「衝撃に関する標準を遵守する(Meet standards for impact)」という2種類の安全標準を特定しています。ここで、システムの境界の外部に注目してください。SysMLのアクターで表現されている運転手(D􈎸vcr)の利害関係者がいます。図6.19では、運転手(D􈎸ver)のコンテキストが示されており、セーフティエンジニア(SafeりEnginccr)の利害関係者はコンテキストの境界の外部のアクターとして示されなければなりません。運転手(D􈎸 vcr)のコンテキストがセーフテイエンジニア(Safcty Enginccr)から関心をもたれているのであれば、逆2ア2
# 第6章 ニーズおよび要求

も成立しなければなりません。セーフティエンジニア(Safcty Engineer)のコンテキストでは、コンテキストの境界の外部のアクターとして運転手(D􈎸 vcr)が示されなければなりません。実際、図6.19のセーフティエンジニア(Safety Enginccr)アクターと「安全である(BeSafC)」ユースケースの間の関連(Association)の線は、図6.20の運転手(Dr􈎺er)アクターと「安全である(Bc s畿)」ユースケースの間の関連(Association)の線と同一です。これは、この2つのユースケースが何らかの形でつながつていることを示しています。この例では、これら2つのユースケースが同じ名前をもっていますが、そうである必要はありません。実際、このアプローチは、どのユースケースが関連しているか、それらが補完的であるか、同じであるか、あるいは対立しているかを特定するための強力な方法です。同じSysMLのユースケースをさらに別のコンテキストから示します。これにより、また別の観点の解釈を理解することができます。次のダイアグラムを見てください。○~T~∧Vendor MaintenancePmvide lana drlllProUd€.olllslon葬タ・ヽゝヽ■ヽ、．噸図6.21 製造者のコンテキストから「安全である」に焦点を当てたニーズコンテキストビュー図6.21は、製造者(Manufacturer)のコンテキストから見たニーズコンテキストビューです。安全性に関連する車の機能を提供することに焦点を当てています。ここでも、「安全である(Be safe)」のユースケースの解釈が大きく異なっています。図6.21にベンダー保守担当(■ndor Maintcnmce)アクターで示される利害関係者が存在することに注意してください。これは、ベンダー保守担当(■ndor Maintenancc)の利害関係者のためのコンテキストがあることを意味し、製造者(Manufacturcr)は利害関係者としてそこに存在するはずです。次のダイアグラムを見てください。27ノ8e safePr.yldcln-6r r.ldyBe safeEnsure batteay lgdi3abledaccess toVendor Maintenance Context- - (con"6sat"r"a' inl｀｀ξl.、、、、、_econstralo"・ヽ、、、_role>Manufacturer図6。22では、保守点検時に車の安全性を確認することに焦点を当てていることが確認できます。ユースケースを使用してモデルに取り込まれる1つのニーズには、多くの解釈があり得るということをこれらの4つの例のすべてが示しています。システムのニーズを完全に理解するためには、複数のコンテキストを考慮することが不可欠です。さまざまな利害関係者がシステムに何を期待しているかを正確に理解するため、利害関係者にもとづくコンテキストを検討しなければなりません。最終的な目標がシステムのユーズを理解することであるとしても、利害関係者がシステムに何を要求しているかを理解しなければシステムのニーズを理解することはできません。繰り返しになりますが、システムのニーズが何であるかを十分に理解するため、システムを検討する際にはコンテキストを考慮することが重要です。システムのコンテキストは、システムの抽象度に応じて、同じニーズでも異なるユースケースとして解釈されることもあります。ここで「効率的である(Be efncient)」という名前のニーズ記述について検討し、図6.15でシステムに対して定義された4つの異なる抽象度について考えてみましょう。これらのそれぞれの抽象度について、次のような解釈ができます。2アイ図6.22 ベンダー保守担当のコンテキストから「安全である」に焦点を当てたニーズコンテキストビュー
# 第6章 ニーズおよび要求

●システムレベル自動車自体であるため、「効率的である(Be emcient)」とは、燃料補給または充電までの間に最低何マイル走行しなければならないかを示します。●サブシステムレベル「効率的である(BC emCient)」とは、ある燃料の使用量に対して出カスループットを提供することを示します。●アセンブリレベル電気モーター制御部品を指す場合があり、異なる効率モードを達成するために異なるアルゴリズムを使用します。●コンポーネントレベル固有のボルトに適用されるかもしれません。そのボルトは、特に軽い材料で作られなければならず、それにより、自動車全体の重量を減らし、より効率的にすることができます。ここでもまた、抽象度の違いによる異なるコンテキストでの解釈、すなわちユースケースが存在します。コンテキストという概念は、次のテーマである妥当性確認に直結する重要なものです。もし1つのニーズに対してさまざまな解釈、すなわちユースケースが存在するのであれば、そのユーズが満たされたことを証明する方法は、ユースケースごとに異なることを意味します。妥当性確認に関しては、次節のシナリオを考えることで対応します。シナリオを視覚化するシステムズエンジニアリングのプロジェクトでもっとも重要な側面の1つは、システムのオリジナルのニーズが満たされていることを証明することです。オリジナルのニーズを満たすには妥当性確認(V」idation)を実施します。妥当性確認が実施されない限り、システムのサービス開始は受け入れられません。妥当性確認(Validation)という用語は、しばしば検証(Verincation)という用語と混同されますので、これらの違いをここで明確にしておく必要があります。本書で使用する定義は以下の通りです。●検証(■􈎸ncation)にて、システムを正しく構築したことを実証することができます。●妥当性確認(ⅥHdation)にて、正しいシステムを構築したことを実証することができます。2ア∫どのようなシステムでも検証(■rincation)および妥当性確認(Ⅵhdation)が不可欠であり、これらの違いをしっかりと理解しておくことが重要です。妥当性確認とは、正しいシステムが構築されたこと、すなわち、オリジナルのニーズを満たしていることを証明することです。そのためには、オリジナルのニーズをすべて理解していなければなりません。前節では、コンテキストという概念を導入し、コンテキストが異なれば同じニーズでも解釈が異なることを説明しました。そのため、ニーズの解釈が異なる可能性がある場合、これらの異なる解釈のすべてを満たさなければなりません。システムのニーズが満たされることの証明は、関連するユースケースが満たされていることを証明することで実現されます。モデリンググで妥当性確認を実施する仕組みは、ユースケースごとに多くのシナリオ(Sccna􈎸o)を作成することです。シナリオは以下の2つの方法で実現することができます。●運用シナリオ(Operalonal Scenario)固有の成果をもたらす一連のイベントまたはアクションを示します。これらの運用シナリオは連続的な性質をもつ場合が多くあります。●パフォーマンスシナリオ(Pettormance Scenario)システムのパラメーターを変更し、ある固有の成果を満たすことを実証します。このパフオーマンスシナリオは数学的な性質をもつ場合が多くあります。SysMLは両方のシナリオを視覚化することができます。これについては、次節にて詳しく説明します。それぞれのコンテキストにおけるすべてのSysMLのユースケースは、いずれかまたは両方のシナリオを使用して妥当性確認をする必要があります。運用シナリオを視覚化する運用シナリオは、ニーズモデリンググにおいて非常に強力かつ不可欠な要素です。ユースケースごとに「もし～であるならどうなるか(What if)」を想定することで、さまざまな選択肢を検討することができます。次のダイアグラムを見てください。2ア`
# 第6章 ニーズおよび要求

dstakeholder role)'DrivercSystemlCarrstakeholder rolerRoad Userdrivecar.Spotted(}図6.23 運用シナリオを示す妥当性確認ビュー:手動でブレーキをかけることに成功する「手動で運転する」のユースケース図6.23は、シナリオがユースケースのインスタンスとして定義されていることを小しています。ブロックのインスタンスについては、第2章「モデルベースシステムズエンジエアリング」ですでに説明しており、ブロックの現実の例を示すために使用しました。SysMLのユースケースのインスタンスも、ユースケースをどのように実現するかという実際の例を検討するという点ではまったく同じです。最初のステップは、妥当性確認をする必要があるSysMLユースケースを特定することです。この例では、図6.18の運転手コンテキスト(Driver Contcxt)から「手動で運転する(D􈏜cmanually)」のユースケースを選択しました。次のステップは、選択したユースケースに関心をもつ利害関係者を特定することです。この例では、自動車(Car)と道路利用者(RoadUscr)の両方が「手動で運転する(D􈏜c manually)」のユースケースに関連しており、その親ユースケースである「運転する(D􈏜e)」を介して継承されていることがわかります。コンテキストの利害関係者をSysMLのライフライン、関連する2つの利害関係者を他のライフラインとしてシーケンス図を作成することができるようになりました。次に、選択したユースケースの意図しない結果を検討し、それに名前を付け、その結果が実現するまでの一連の流れを示します。図6.23では、シナリオを「手動でブレーキをかけることに成功する(succcssful manualapplication of brakes)」と名付けました。この名前は、意図した結果をうまく簡潔に要約しています。次に、ダイアグラム上にイベントを追加しますc最初のイベントは、運転手(Dr􈎺 cr)2アアと自動車(Car)の間の相互作用で、「自動車を運転する(drivc carO)」と名付けました。次に、運転手(D􈏜cr)と道路利用者(Road Uscr)との間の相互作用があり、これは「道路を監視する(momtor roado)」と名付け、これに対する直接的な応答を「自動車が発見された(carspottcdo)」としました。次に、運転手(D􈎸 vcr)と自動車(Car)との間の相互作用として、「ブレーキをかける(apply brakcsO)」という相互作用があります。ユースケースのシナリオを定義するとき、相互作用に名前を付けるために使用する言語は、意図的に非技術的な表現で書かれます。なぜなら、使用する言語はこのダイアグラムを見る対象となる利害関係者が理解できなければならないためです。この時点では、シナリオを理解しやすくかつ伝えやすくすることが最大の目的なので、それを意識して言語を記述します。シーケンス図は、SysMLのユースケース図と一貫性をもつ必要があり、以下のSysMLの一貫性チェックが適用されている必要があります。●シーケンス図上のそれぞれのライフラインは、ユースケース図上のアクターまたは境界である必要があります。●シーケンス図上のそれぞれの相互作用は、ユースケース図上のアクターとユースケース間の関連(Associtton)のインスタンスでなければなりません。2つのダイアグラムに一貫性がない場合、シーケンス図かユースケース図のいずれかを変更し、それらの間に一貫性をもたせる必要があります。たとえば、シーケンス図にあるライフラインがユースケース図にない場合、ユースケース図にアクターまたは境界を追加するか、シーケンス図上からライフラインを削除する必要があります。通常、それぞれのユースケースに対して複数のシナリオを示し、同じ結果に対してモデルがどのように反応するかを調べ、典型的な条件下でシステムがどのように振る舞わなければならないかを理解することができます。これらのシナリオは、すべてがうまくいっていることを示すため、「晴れの日シナリオ(Sunny― Dγ Sccnmo)」と呼ばれます。この考え方の非常に強力な側面は、何かがうまくいかないときに何が起こるのか、すなわち「雨の日シナリオ(Rtty― Day Scen􈎹o)」を検討することにあります。次のダイアグラムを見てください。2ア∂
# 第6章 ニーズおよび要求

(stakeholder role,DriverxSystemrCar<stakeholder role>Road Userdrivemonitorapply brakes0alert driver0図6.24 運用シナリオを示す妥当性確認ビュー:自動ブレーキが作動する「手動で運転する」のユースケース図6.24は、図6.23のシナリオと同じユースケースのシナリオですが、見た目がまったく異なります。この例では、運転手(D􈏜cr)が自動車(C額)を運転しているときに、自動車(Car)自身が他の道路利用者(Road Uscr)を発見し、自らブレーキをかける場合のシナリオを示しています。このシナリオは「自動ブレーキが作動する(automatic applicationof brabs)」と名付けられています。このシナリオは、「手動でブレーキをかけることに成功する(succcssful manual applicationof brakcs)」のシナリオ同様、運転手(Dr􈎺er)と自動車(Car)との間の相互作用から始まりますが、今回は他の道路利用者(Road User)のために道路を監視しているのは自動車(Car)の方です。今回は運転手(D􈎸 ver)ではなく自動車(Car)がブレーキをかけます。それぞれのユースケースに対して、どのくらいの数のシナリオを作成すればよいでしょうか? これは、ユースケースの抽象度に依存する可能性があります。以下の3つの経験則を考えてみましょう。● 1つのユースケースに対して、1つのシナリオしかないユースケースが詳細すぎるため、よリハイレベルなユースケースとして抽象化する必要があります。● 1つのユースケースに対して、2～ 9のシナリオがあるユースケースを明確に理解していることを示す十分な数のシナリオがあります。● 1つのユースケースに対して10以上のシナリオがあるユースケースがハイレベルすぎるため、より詳細なレベルのユースケースとして分解2アフ(constraintDPoutconstrcints{Pout=Txw}ρarα meteぉT:Realpout:Realw:Rea:( constraint)tPower lnconstrdints{Pin = Vll}ρO「●metersi:RealPin:RealV:Real(constraintDEfficiencac。●st“α′″rs(E=PouザPin}porometersPin : RealE : RealPout: Real(constraint )Decisioncο″stra′′,お{IF E>=75%THEN Decision=True ELSE Decision=FALSE}parametersE: RealDecision : Booleanする必要があります。この3つのルールにより、ユースケース図のチェックをもう一段階強化することができます。次節では、もう1つのシナリオであるパフォーマンスシナリオ(Pettrmancc Sccnario)を説明します。パフォーマンスシナリオを狙覚化するパフォーマンスシナリオ(Pcformance Scenario)は、さまざまなケースを想定して検討するという点では、運用シナリオ(Operational Scenario)と同様です。しかし、固有の成果につながる一連の事象を検討するのではなく、固有の成果をもたらすために、パラメーターの値をどのように変化させるかを検討します。パフォーマンスシナリオ(Pettrmance Scenano)は、SysMLのパラメトリック図を使用して視覚化します。パラメトリック図を使用するためには、パラメトリック制約を定義したブロック定義図も定義する必要があります。次のダイアグラムを見てください。2θθ図6.25「効率的である」のユースケースの制約定義を示す妥当性確認ビュー
# 第6章 ニーズおよび要求

図6.25は、SysMLのブロック定義図を使用し、妥当性確認ビューで「効率的である(Bcefncient)」のユースケースの制約の定義を示しています。図6.25は、図6■ 8の運転手コンテキスト(Drivcr Context)から「効率的である(Becfncicnt)」のユースケースを検討しています。ここでは、SysMLの標準的な構成要素である<<constraint>>としてステレオタイプ化された4つのブロックを示しています。それぞれの制約ブロックは3つの区画をもちます。●名前(Name)制約の名前を示します。●制約の定義(Constraint Defin􈎹 on)方程式、ヒューリスティック、ルール、その他の表記法を用いた制約の定義を示します。●パラメーターの定義(Parameter Definition)制約定義で使用されるパラメーターの定義を示します。図6.25では、以下の4つの制約が定義されています。● Power out(Pout)トルクと角速度の積で定義されます。● Powerln(Pin)電圧と電流の積で定義されます。(D)Efficiency (E)Pout/Pinの比率で定義されます。● Dec!s:on単純なヒューリスティックで定義されます。これらの制約は、標準ライブラリの一部としてあらかじめ定義されている場合と、そのシステム向けに特別に定義されている場合があります。どちらの場合にも、複数のプロジェクトで使用できる制約のライブラリを構築することができます。2∂ /Batlery.CurentBattery.VoltageDecision:iEfficien.y rDffisionMotor.TorquePout:RealrPoutそれぞれの制約をインスタンス化し、SysMLのパラメトリック図(P"amet􈎸c Diagram)にてそれぞれの制約を接続します。次のダイアグラムを見てください。図6.26「効率的である」のユースケースのパラメトリックによる妥当性確認図6.26は、SysMLのパラメトリック図を使用し、妥当性確認ビューで「効率的である(Bc cmcicnt)」のユースケースのパラメトリックによる妥当性確認を示しています。SysMLのパラメトリック図は主に3つの要素から構成されます。以下を見てください。●パラメ トlプック (Parametric)図6.25で定義された制約のインスタンスであり、角丸の箱で視覚化されています。インスタンス名とその型である制約を分離するため、コロン(:)を使用していることに注意してください。それぞれのパラメトリックは、いくつかのパラメーターをもちます。そのパラメーターは、パラメトリックを示す角丸の箱の中の小さな正方形として視覚化されています。●パラメーターブロック(Parameter Block)図6.26では、左側にある長方形として視覚化されています。モデル内のどこかのブロックおよび必要なパラメーターの元となるブロックの固有のプロパティを参照します。ブロック名とそのプロパティを分離するための表記法としてピリオド(.)を使用しています。ピリオドの左はブロック名、ピリオドの右はそのプロパティを示します。●接続 (Connection)線で視覚化されます。モデルのパラメーターとパラメトリック制約の固有のパラメーターを接続します。パラメトリック図は、パラメトリック制約のつながりとその接続を不しています。このようにして、入カパラメーターのいくつかを変更して、結果の出力を監視することができます。たとえば、パラメトリックが異なるバッテリーを示す場合、その車が「効率的である(Be emcicnt)」のユースケースを満たすかどうか、さまざまなシナリオを検討すること2θ2
# 第6章 ニーズおよび要求

ができます。パラメトリック図の潜在的な価値は実に大きいです。しかし、ツールごとに機能が大きく異なるため、この価値を実現できないことも多くあります。パラメトリック図は、SysMLの視覚的な世界と、シミュレーションなどの数学的な世界との間の自然な橋渡しになります。そのため、モデルの利点を最大限に発揮するためには、パラメトリック図を数学的なツールと組み合わせて使用できることが望ましいです。この場合、ツールの相互運用性が最も大きな課題となります。実際のプロジェクトでは、運用シナリオとパフォーマンスシナリオの両方を使用することで、多くの異なるシナリオを検討できます。その結果、根本的なユースケースとニーズを満足させることができる非常に強力な仕組みとなります。これらのシナリオを定義し、関連する利害関係者からそのシナリオが正しいという合意を得ることができれば、そのシナリオが妥当性確認の中心となり、ひいては最終的なシステムの受け入れ確認として使用できます。シナリオはどのプロジェクトでもできるだけ早く定義するべきです。なぜなら、プロジェクトのライフサイクルを通して継続的に妥当性確認を実施する必要があり、その後のすべての設計作業でシナリオを追跡し、そのシナリオを満たすよう実証しなければならないためです。ライフサイクルとプロセス本章で説明してきたユーズモデリンググは、一般的な開発ライフサイクルの中で実施されます。これを考慮し、第4章「ライフサイクル」で紹介した開発ライフサイクルモデルを再確認してみましょう。次のダイアグラムを見てください。(stage}}Production《stage》じ薔:i2a遷On(stage!tConcept({staSetRetirement(stage,tDevelopment図6.27 開発ライフサイクルモデルの例2∂′図6.27は、SysMLのシーケンス図を使用し、開発ライフサイクルの例を示しています。このライフサイクルモデルのステージは、ISO/1EC/1EEE 15288からきており、ステージの実施は単純な線型シーケンスです。ニーズモデリンググは、ダイアグラムの最初のステージであるコンセプト(Conccpt)で実施されます。このステージでニーズモデリンググの大部分が実施されますが、時間の経過とともにニーズおよびニーズに関するコンテキストが変化する可能性があるため、ライフサイクル全体を通してニーズを見直すことが必要となります。ニーズモデリンググのアプローチをベストプラクティスに関連付けする必要があり、これは、第4章「ライフサイクル」のプロセスモデリンググがコンプライアンスに使用される可能性があるという例です。第5章「システムズエンジニアリングプロセス」で説明した「プロセスモデリンググヘの7つのビューによるアプローチ(Sevcn―Ⅵews AppЮ ach toPЮccss Modcling)」を使用するならば、ISO/1EC/1EEE 15288を抽象化したプロセスコンテンツビューが使用できます。次のダイアグラムを見てください。( process))Stakeholder Needs and Requirements Definition Process(outcome))ConstraintContext of usePerformance measurePriorityResou rceStakeholderStakeholder agreementStakeholder needTraceability(activity>Analyze stakeholder req uirements{)Defi ne stakeholder needs$Develop operation conceptQManage stakeholder needs and requirements definition0Prepare for stakeholder needs definition0Transform stakeholder needs into stakeholder requirements$図6.28 !SO/1EC/1EEE 15288の利害関係者二―ズおよび要求定義プロセスのプロセスコンテンツビュー図6.28は、SysMLのブロック定義図を使用し、ISO/1EC/1EEE 15288の利害関係者ニーズおよび要求定義プロセスのプロセスコンテンツビューを示しています。プロセス全体はSysMLのブロックで表現し、成果はSysMLのプロパテイ、アクテイ2∂イ
# 第6章 ニーズおよび要求

ビティはSysMLのオペレーションで表現しています。ここで示したプロセスは、規定されたアプローチではなく、最低限推奨されるアクティビティと結果としての成果を示しています。本章で説明したニーズモデリンググの手法をこのベストプラクティスのプロセスに対応させることができれば、そのモデリンググ技法に信頼性と実績を与えることができます。ISO/1EC/1EEE 15288で要求されるアクティビティをモデリンググに当てはめます。以下を見てください。●利害関係者ニーズの定義の準備(Prepare for stakeholder needs definitiOnO)モデリンググ用語では、ニーズモデリンググに使用されるソース要素の特定に関連し、ソース要素ビューの作成につながります。●利害関係者ニーズの定義(Delne stakeholder needso)ニーズ記述ビューとして初期のニーズを定義することに関連しています。●利害関係者要求の分析(Analyze stakeholder requirementso)関連するコンテキストを特定し、それぞれのコンテキストを定義します。その結果、多くのコンテキスト定義ビューが作成され、それに関連するニーズコンテキストビューが開発されることになります。●運用コンセプトの開発(Develop operalon concepto)運用コンセプトを検討するための運用シナリオとパフオーマンスシナリオの開発に関するものです。これにより、さまざまな妥当性確認ビューが作成されることになります。●利害関係者ニーズの利害関係者要求への変換(Transform stakeholder needs intOStakehOlder requirementS())これは、同じモデリンググ技法を異なる抽象度で適用することに関連します。たとえば、オントロジーには、利害関係者ニーズと利害関係者要求という2種類のニーズが定義されており、これらは互いに関連しています。これら2種類のニーズは、ニーズビューのいずれか、またはすべてを定義することができます。●利害関係者ニーズおよび要求求定義の管理(Manage stakeholder needs and requirementsdefinitiOn())これは、ニーズモデルの全体的な管理とトレーサビリティに関連します。オントロジーの効果でトレーサビリティはモデル内に含まれ、フレームヮークのビュー定義が、ビューのトレーサビリティとともに、それぞれのビューの根拠、内容、構造などのすべてを管理します。ISO/1EC/1EEE 15288で要求される成果をモデリンググに当てはめます。次ページを見てください。2θ∫●制約(Constraint)これはステレオタイプ<<consiaint>>による制約関連(Constraint)をもつすべてのユースケースに当てはまります。●使用時のコンテキスト(Context of use)運用シナリオに当てはまります。●パフォーマンス指標(Perormance meaSure)パフォーマンスシナリオに当てはまります。●優先度(Priority)ニーズ記述ビューにあるニーズのプロパテイに当てはまります。●リツース(Resource)ニーズ記述ビューにあるニーズのプロパテイに当てはまります。●利害関係者(Stakeholder)コンテキスト定義ビューの利害関係者に当てはまります。●利害関係者の合意(Stakeholder agreement)ビューを集めることで利害関係者の合意が得られます。●利害関係者の二一ズ(Stakeho!der Need)ニーズ記述ビューに当てはまります。● トレーサビリティ(丁raceabinty)これはオントロジー定義ビューとビューポイント関係ビューにより、フレームヮークで定義されます。これらのモデリンググビューは、次節で説明するニーズパースペクテイブ(NeedPcrspective)をもとに定義できるようになります。フレームワークを定義するこれまで作成したビューは、第2章「モデルベースシステムズエンジニアリング」で詳しく説明した「1枚のスライドのMBSE(MBSE in a slide)」の中央部分を示したものです。それぞれのビューはSySMLを用いて視覚化されており、これは「1枚のスライドのMBSE(MBSE in a slide)」の右側部分を示したものです。これらのビューを組み合わせることで全体的なモデルとなりますが、これらのビュー間で一貫性をもつことが重要です。一貫性がなければ、それはビューではなく単なる画像です。すべてのビューの定義は、フレームワークに取り込まれることが重要となりますが、それが「1枚のスライドのMBSE(MBSE in a slidc)」の左側部分に相当します。フレームヮークは、オントロジーとビューポイントから構成されます。本節の目的は、これらのビューポイントが正しく定義されていることを徹底的に確認することです。2θび
# 第6章 ニーズおよび要求

フL=ム2=クエのビュ=璽イン_卜奎定義立る
# 第6章 ニーズおよび要求

●主要ユースケースは以下の下位ユースケースを含みます。。「それぞれのニーズを記述する(Desc‖ be each Need)」。「コンテキストにおけるニーズを検討する(Consider needs in Context)」は、「妥当性確認のアプローチを定義する(Define va‖ datiOn apprOach)」ぉょび「コンテキストを特定する(!den‖ y contexts)」を含みます。●主要ユースケースには、4つの制約があります。。「モデルベースでなければならない(Must be mode卜based)」。「標準に準拠する(Comply with standards)」。「ニーズのトレーサビリティを確保する(Ensure traceab􈎹 ty of needs)」。「一貫したスタイルを確保する(Ensure consistent style)」図6.29では、SysMLのユースケースのそれぞれが、くくconccrn>>としてステレオタイプ化されていることに注目してください。関心事(Concem)とは、フレームヮークまたはそのビューポイントの1つに関連するエーズのことです。オントロジー定義ビューを定義するオントロジー定義ビュー(Ontology DennitiOn Ⅵew)は、フレームヮークに関連するすべての概念と関連する用語をオントロジーとして取り込みます。図6.5でニーズに関係するビューのオントロジーを定義しましたが、実はこのビューがオントロジー定義ビューです。このビューで示されるオントロジー要素は、本章でこれまでに示したビューで使用されたあらゆるステレオタイプを提供しています。他の章で説明した通り、関連するオントロジー要素は、しばしば1つのパースペクテイブ(Pcrspective)として集められます。本章では、ニーズに関連する新しいパースペクティブ(Perspcctive)が作成されました。:_,｀こユポイント関ビューを定義するビューポイント関係ビュー(Ⅵewpoint Relationship Ⅵcw)は、必要なビューおよびその定義を含むビューポイントを特定します。ビューポイントは、ビューのテンプレートと考えることができることを忘れないでください。これらのビューポイントは、共通のテーマをもつビューポイントの集合であるパースペクティブ(Pcrspective)にまとめられます。本節では、ニーズに関連するビューを定義することに焦点を当てているため、ニーズパースペクティブ(Nccd Pcrspcctivc)を作成します。これまで説明してきたビューの関係性は次のダイアグラムの通りです。2∂フ(pErspectiveDil6€d Fsrspe.tlvs(vi€$Lpoint>Rrb S.t lreffnitbnVlilrp.lfi(viewpoint,)ilaod D66crlftlonVleilpolnt(viewpointDSorfrio El6manllrigwoint(viewpoint,Context(viewpointDYrl6a{on Vlerpalnt(viewpoint)Contst DeffalttonVlorn?ointdenms脚:“ f∝ )■..ホ1..*´ de“議s use∞鉾s‐ m“ d On■…■..・■.:>1..l deffnec context for..:desc􈎸bes neods｀based o●図6.30 ニーズパースペクティブのビューポイント関係ビュー図6.30は、SysMLのブロック定義図を使用し、ニーズパースペクテイブのビューポイント関係ビューを示しています。ニーズパースペクティブ(Need Perspective)はステレオタイプ<くperspective>>が付与されたSysMLのパッケージとして示され、いくつかのビューポイントが含まれています。以下を見てください。●ソース要素ビューポイント(Source Element Viewpoint)モデルを構成するニーズのすべてのソースを特定します。ニーズ記述ビューポイント(Necd Dcscription Ⅵewpoint)とニーズコンテキストビューポイント(Necd ContcxtⅥcwpoint)は、いずれもソース要素ビューポイント(Sourcc Element Ⅵewpoint)をベースにしています。●ルールセット定義ビューポイント(Rule Set Definition Viewpoint)ニーズ記述ビューポイント(Need Descnption Vicwpoint)に合まれる情報を制約するルー2 A“nncs rulcsおrB:AはBのためのルールを定義するA describcs nccds bascd on B:AはBにもとづくニーズを記述するA dcnnes contextおrB:AはBのためのコンテキストを定義するA validatcs B:AはBの妥当性確認をする2フθ
# 第6章 ニーズおよび要求

ルを定義します。●ニーズ記述ビューポイント(Need Description Viewpoint)個々のニーズについてテキストベースの説明を提供します。ルールセット定義ビューポイント(Rule Set Dcnn􈎸 on Ⅵewpdnt)にて制約され、ソース要素ビューポイント(SourccElement Ⅵewpoint)にもとづいています。●ニーズコンテキストビューポイント(Need Context Viewpoint)ソース要素ビューポイント(Source Element Ⅵewpoint)に含まれる情報にもとづく一連のユースケースを記述します。そして、そのコンテキストがコンテキスト定義ビューポイント(Contcxt Dcinition Ⅵewpoint)にて定義され、妥当性確認ビューポイント(Ⅵlidation Ⅵcwpoint)にて妥当性確認されます。●コンテキスト定義ビューポイント(Context Definition Viewpoint)さまざまなニーズコンテキストビューポイント(Need Contcxt Ⅵewpoint)のコンテキストを定義します。●妥当性確認ビューポイント(Va‖dation Viewpoint)ニーズコンテキストビューポイント(Necd Context Viewpoint)で定義されたユースケースの妥当性確認をします。ここで確認したそれぞれのビューポイントは、ビューポイントコンテキストビュー(Viewpoint Context Ⅵew)とビューポイント定義ビュー(Ⅵewpoint Dcnnidon View)にて説明されます。ビューポイントコンテキストビューを定義するビューポイントコンテキストビュー(Ⅵewpoint Context Vicw)は、特定のビューポイント、すなわちそのビューの集合がなぜ必要なのかを明示します。また、そのビューポイントに関心をもつ利害関係者を特定し、それぞれの利害関係者がフレームワークからどのような利益を得たいと考えているかを明らかにします。2フ/貴《sヽkeholder role》′′′´期為:"ヽ温ヽ　・‐ｎＣSupport aaptureof toal.S!pport captua!Sup""“pture qf nedrof“pabit‖ esaequircm€ntsゝlpp。●Caメure OfDesc.ibe ea.h nedDefin€ attribute図6.31 ニーズ記述ビューポイントのビューポイントコンテキストビュー図6.31は、SysMLのユースケース図を使用し、ニーズ記述ビューポイントのビューポイントコンテキストビューを示しています。図6.31が図6.29と非常によく似ていることに注意してください。これは、それぞれのビューポイントコンテキストビューが上位のフレームヮークコンテキストビューと一貫性をもたなければならないためです。実際、この場合のように、ビューポイントコンテキストビュー上の上位レベルのユースケースが、フレームヮークコンテキストビューから直接取得されることはよくあることです。このビューポイントに新たに含まれたもの、そしてこのビューポイントから除外されたものを確認しましょう。以下を見てください。●図6.31には、「それぞれのニーズを記述する(Dcsc􈎸 bc c¨h nccd)」が含まれています。さらに、このユースケースは3つの下位ユースケースに分解されます。「属性の値を定義する(Denne attbutc valucs)」、「ソースヘのトレーサビリティを定義する(Dennetraccability to source)」、「ニーズ記述間の関係性を定義する(Deine d■ ionships bctwccnnced dcscriptions)」です。●図6.31からは、図6.29の「コンテキストにおけるニーズを検討する(Consider ncedsin context)」が意図的に除外されています。これは、このビューポイントの関心事ではなく、むしろニーズコンテキストビューポイントのためのビューポイントコンテキストビューに含まれるためです。2フ2needsRequirernem
# 第6章 ニーズおよび要求

ここで注意すべきことは、検討しているビューポイントに関連するユースケースのみを含めることです。これがコンテキストの重要な点です。ビューポイントが存在しなければならない理由が示されましたので、ビューポイント定義ビューを検討することにしましょう。ビューポイント定義ビューを定義するビューポイント定義ビュー(Ⅵcwpoint Dein􈎸 on Ⅵew)は、ビューポイントに含まれるオントロジー要素を定義します。●どのオントロジー要素がビューポイントにて許容されていますか?●どのオントロジー要素がビューポイントにて任意とされていますか?●どのオントロジー要素がビューポイントにて禁止されていますか?ビューポイント定義ビューでは1つのビューポイントに焦点を当て、選択されるオントロジー要素および要素間の関係性に注目します。次のダイアグラムを見てください。《viewpo書nt》縛eed Descript:onViewpol轟t{(ontology elern€nt$<ontology elementr Need DescriptionSource Element1“黎{ tracestoＯ０ｒｔｌｅｐ 籟Ｃｒｉも鸞ｌ ｅｔＤ ヒ燿a融.eOrittnpriorityVattdatlon1.F■_幸図6.32 ニーズ記述ビューポイントのビューポイント定義ビュー3 Atraccsto B:AはBを追跡する2フリ図6.32は、SysMLのブロック定義図を使用し、ニーズ記述ビューポイントのビューポイント定義ビューを示しています。ビューポイント定義ビューは、ビューポイントにて記述されるすべてのビューで許容される内容を正確に定義するため、ビューポイント定義ビューは非常に重要です。このビューポイントは常に以下の情報を含みます。●ビューポイント名<<viewpoint>>でステレオタイプ化された、このビューの焦点となるビューポイントの名前を示します。ここで特定されるビューポイントは、図6.30で示されたビューポイント関係ビューに由来するものでなければなりません。●オントロジー要素く<ontology elemen>>でステレオタイプ化された、いくつかのオントロジー要素を示します。それぞれのオントロジー要素は、図6.5に示されたオントロジー定義ビューに由来するものでなければなりません。このビューポイントに関するビューで正当なオントロジー要素は以下の2つです。●ソース要素(Source Element)ニーズの起源を示します。●二一ズ記述(Need Description)ここに表示されるプロパティとともに、それぞれのニーズを説明します。ビューポイントとそれぞれのビューポイント上で認められるオントロジー要素は、いくつかのルールにて制約されます。このルールは、ニーズパースペクティブのためのルールセット定義ビュー(Ruleset Dennition Ⅵew)で説明されます。ルーリ♭セ｀ントビューを定義するルールセット定義ビュー(Ruleset Dcnn􈎸 on Ⅵew)は、モデルがフレームヮークと一貫性をもつことを保証するため、モデルに適用するルールを特定して定義します。ルールは、主にオントロジー定義ビューとビューポイント関係ビューにもとづいています。いずれの場合も、存在する主要な関係性と多重度を特定することでルールが定義されます。2フイ
# 第6章 ニーズおよび要求

●ビューポイント定義ビュー上のビューポイント間●オントロジー定義ビュー上のオントロジー要素間ルールのいくつかの例を示します。次のダイアグラムを見てください。図6.33 ルールセット定義ビューの例図6.33は、SysMLのプロック定義図を使用し、SysMLのルールセット定義ビューを示しています。図6.33のそれぞれのブロックは、オントロジー定義ビューまたはビューポイント関係ビューのいずれかから派生したルールです。これらのルールは以下のように定義されています。●ルール1:それぞれのニーズコンテキストビューには、コンテキスト定義ビューが存在しなければなりません(For e∝h Need Contcxt Ⅵcw,thcre must be a Context DeinitionⅥ ew)図6.30で示したビューポイント関係ビューから派生したルールです。このルールは、フレームヮークの一部として作成されたそれぞれのビューポイントに関連するビューをいくつ作成できるかを定義するのに役立ちます。これは多重度で示されます。●ルール2:それぞれのニーズコンテキストビューには、少なくとも1つのソース要素ビューが存在しなければなりません(br cach Nccd Description View,there must bc at lcastone Sourcc Elcmc􈎹 Ⅵew)図6.30で示したビューポイント関係ビューから派生したルールです。このルールは、すべてのニーズ記述のトレーサビリティをもれなく実施するのに役立ちます。ソース要素ビューが必須であることは、1¨*の多重度で示されています。●ルール3:それぞれのニーズコンテキストビューには、少なくとも1つの妥当性確認ビューが存在しなければならない(Dr cach Need Context Ⅵcw,thcre must be atleast oneValid■ ion View)図6.30で示したビューポイント関係ビューから派生したルールです。このルールは、ニーズコンテキストビューにあるそれぞれのユースケースに対する妥当性確認が必須であることを定めています。妥当性確認ビューがない場合、「参照元が見つかりません」《rule》RulelnotesFor each Need Conturt View,there must be o ContextDefinition View《ru!e》Rule2notesFor eoch Need DescriptianView, there must be at leastane Source Element View《ru:e》Ru:e3natesFor each Need Contert Vieur,there must be at leost oneValidation View2フ∫というエラーメッセージが表示されるかもしれません。ルールは、ビューポイントを示すビューポイント関係ビュー、そしてオントロジー要素を示すオントロジー定義ビューから派生していることに注目してください。実際のルールの記述自体は、ビューポイントのインスタンスであるビュー、そしてオントロジー要素のインスタンスに適用されます。他にもルールを定義することができますが、すべての関係性がルールになるわけではありません。どれをルールとするかはモデラーの判断次第です。まとめニーズの概念について検討し、それに関連するモデリンググについて説明しました。はじめに、ニーズという概念の重要性と、要求および能力といったニーズの種類を説明しました。そして、ニーズを分析する2つの方法を説明しました。その方法は、テキストベースで特性と説明を記述する方法と、それぞれのニーズのコンテキストを探求することで真のニーズを理解する方法です。ニーズモデリンググの唯一の重要な側面であるコンテキストを紹介し、コンテキストを理解するためには、システムに関心をもつ利害関係者を理解することが非常に重要であることを説明しました。利害関係者は、他の利害関係者と異なる方法でニーズを解釈する可能性があり、これはモデリンググのユースケースとして知られています。それぞれのユースケース、およびユースケースに関連するニーズ記述は妥当性確認されなければならず、2つの方法を紹介しました。その方法は、パフォーマンスとオペレーションの妥当性確認であり、シナリオを使用してモデリンググされ、妥当性確認ビューで視覚化されます。また、ベストプラクティスの重要性についても説明し、ISO/1EC/1EEE 15288の固有のプロセスを検討し、モデリンググビューをそのアクティビティおよび成果に直接関連付けることで、ビューとの関連付けを行いました。最後に、これらのビューを「アーキテクチャフレームヮークのためのフレームヮーク(Framcworkおr Architecmrc namewoよs:FAF)」の全体的なフレームヮーク定義の一部として取り込みました。「アーキテクチャフレームワークのためのフレームヮーク(FrameworkおrArchitecture Framcworks:FAF)」は、モデリンググをするための多くのビューから構成されて2フび
# 第6章 ニーズおよび要求

います。本章では、テキストベースの単純なニーズを、MBSEのモデリンググ技法にて分析し理解する方法を紹介しました。次章では、ニーズモデリンググから先に進み、設計とそれに関連するさまざまな側面のモデリング技法について説明します。演習問題1.フレームワーク定義またはビューポイント定義に関連するニーズとして、関心事(Conccm)の概念が紹介されました。図6.6を再確認し、そこに関心事の概念を追加してください。2.あなたの組織に特有の利害関係者を検討し、コンテキスト定義ビューに取り込んでください。3.身近なプロジェクトに関するニーズを1つ選び、ニーズ記述ビューを作成してテキストで説明してください。4.1.と2.にもとづき、3人から4人の異なる利害関係者の観点からニーズの記述を考察し、ニーズコンテキストビューを作成してそれぞれを説明してください。5.ニーズコンテキストビューから任意のユースケースを選び、いくつかの妥当性確認ビューを定義してください。パフォーマンスシナリオと運用シナリオを検討し、それぞれのシナリオを比較してください。6.オントロジー関連が省略されているため、図6.31は一貫性がとれていません。それぞれのオントロジー要素とオントロジー関係を確認し、欠けている要素と関連を推論してください。参考文献● (Holt&Perry 2019)Holt,J.D.and Perry,S.A。(2019)SysMiL for Systclns Engineering― arnodel― based approach.′ I｀hird edition.IET:Publishing,Stcvcnage,UK,2019● (Royce 1970)Royce,Winston.:Mianaging thc Developl■ ent of Large Sotware Systeins,Pro―ceedings ofIEEE WESCON,26(August):1-92フア
# 第6章 ニーズおよび要求

キテクチャモデルには、本書にて説明されたどのようなビューも含まれる可能性があります。●アーキテクチャのビューポイント(Architecture viewpoint)ビューポイントは、オントロジーとともにフレームヮーク全体の一部として定義されます。本書ではこれらのMBSEフレームワークを全体にわたって少しずつ定義しており、最終的には完全なMBSEフレームヮークとなります。●概念 (Concept)これらの概念は、本書のMBSEフレームワークの一部であるオントロジーとして定義されています。●コンテキスト(Context)アーキテクチャのコンテキストは、そのフレームヮークが必要とされる理由を定義します。これは、それぞれのパースペクティブのために定義され、第6章「ニーズおよび要求」のニーズモデリンググのアプローチを使用して説明しました。●イネーブリングシステム(Enab‖ ng system)
# 第6章 ニーズおよび要求

ス図を使用していることに注意してください。図7.23は以下のように読みます。●設計フレームワークの主な目的は、「設計の能力を提供する(Provide designCapability)」です。このユースケースは一般的な用語で構成されており、コンテキストの全体的な意図を1つの動詞句で表現しています。あるコンテキストを示すユースケース図の中から最上位のユースケースを見つけ出すことは非常に有益です。また、このユースケースは包含関連(lnclude)と制約関連(Constraint)をもちます。これは、一般的に最上位のユースケースを特定するものであり、あらゆるコンテキストを読むための出発点として推奨されるものです。●最上位のユースケースには、「アーキテクチャ設計をサポートする(Supportarchitectural design)」と「詳細設計をサポートする(Support detaned design)」の2つの特化(Specialization)があります。これは、親ユースケースである「設計の能力を提供する(Provide design capab􈎹 ty)」に付随するものですが、子ユースケースの特化(Specialization)にも継承されることを意味します。●全体的な設計の能力は「モデルベースでなければならない(Must be mode卜based)」です。これは、システムズエンジニアリングのコンテキストビューのすべてに登場する共通のユースケースです。MBSEは本書が提唱するアプローチなので、ここで繰り返されても驚くことではありません。●本書のもう1つの共通テーマは「標準に準拠する(Comply with standards)」であり、ここでもユースケースとして登場しています。これにより、システムズエンジニアリングで実施するすべてのことにベストプラクテイスが適用され、関心をもつ利害関係者に対して、私たちのアプローチ全般が実証されることになります。●ほぼすべてのシステムズエンジニアリングの標準に記載されている共通活動の1つは、「トレーサビリティを確保する(Ensure traceab􈎹 ty)」ことです。これは、オリジナルのニーズヘの準拠を実証し、モデルに変更があった場合にはエンジニアリングにて影響分析を実施できるようにするために不可欠です。●最上位のユースケースには4つの包含関連(lnclude)があり、その1つが「候補となる解決策を定義する(Defhe candidate so!utions)」です。堅牢な設計を実現するためは、同じ問題を解決するためのさまざまな解決策を検討することが重要です。●解決策の候補に関して「候補となる解決策を評価する(Assess candidate solutions)」ノ′び
# 第6章 ニーズおよび要求

図を使用していることに注意してください。図8.14は、以下のように読みます。●検証および妥当性確認のフレームワークの主な目的は2つの方法で「テストを定義する(Denne testing)」こと、すなわち、「検証アクティビティのためのテストを定義する(Denne testing b Verincation activity)」ことと、「妥当性確認のためのテストを定義する(Denne testingおr Validation activity)」ことです。特化(Specialization)の継承により、以下の3つの包含関連(Include)は「テストを定義する(Dcnne testing)」のユースケースだけでなく、これら2つの特化(Specidization)したユースケースにも適用されます。●テストコンテキストを定義する(Define Testing Context)検証と妥当性確認の両方において、テストを実施する理由をテストコンテキスト(■ sting Context)として理解する必要があります。●テストを定義する(Define tests)実際のテストを、その構造(「テスト構造を定義する〈Dennc test structurc〉」)とテストケース(「固有のテストケースを定義する〈Deine spccinc tcst cases〉」)の観点から定義することが必要です。●テストセットアップを定義する(Define test setup)テストケースを実行するために必要な全体的なセットアップを定義する必要があります。図8.14は、SysMLのそれぞれのユースケースが関心事(Concem)としてステレオタイプ化されていることに注目してください。関心事(Concem)は、特にフレームヮークまたはそのビューポイントの1つに関連するニーズです。オントロジー定義ビューを定義するオントロジー定義ビュー(Ontology Dennition Ⅵcw)は、フレームワークに関連するすべての概念と関連する用語をオントロジーとして取り込みます。図8.6で検証および妥当性確認に関係するビューのオントロジーを定義しましたが、実はこのビューがオントロジー定義ビューです。このビューで示されるオントロジー要素は、本章でこれまでに示したビューで使用されたあらゆるステレオタイプを提供しています。他の章で説明した通り、関連するオントロジー要素は、しばしば1つのパースペクテイブ(Perspcctivc)として集められます。本章では、検証および妥当性確認に関連する新しいパースペクティブ(Pcrspcctivc)が作成されました。フア∂
# 第6章 ニーズおよび要求

●ライフサイクルビューポイント(Life Cyc!e Viewpoint)
# 第6章 ニーズおよび要求

ためのさらなる調査が必要な場合、ニーズパースペクティブ(Needs Perspcctivc)のビューポイントを適用することでプロセスパースペクティブ(Process Perspcctive)のプロセスコンテキストビューポイントを強化することができます。リスク管理の分野全体に対して、新たにリスクパースペクティブ(Risk Perspective)を定義できます。これについての詳細は本書でカバーしませんが、これに関して出発点になりそうなビューポイントを後ほどいくつか紹介します。次は、リスク分析(Analyzc riskso)アクティビティを説明します。イノイ