
# 第7章 設計のモデリング

設計のモデリンググ効果的な設計にもとづく解決策を定義する方法を紹介します。そして、アーキテクチャ設計、詳細設計などの設計の抽象化のレベルについて説明します。また、論理設計、機能設計、物理設計など、さまざまな設計の観点について紹介し、それらの関係を定義します。そして、設計がシステムライフサイクルの中でどのように位置づけられるか、どのプロセスと関連するのか、何に準拠するのかについて説明します。本章の内容は以下の通りです。●設計の種類、特にアーキテクチャ設計および詳細設計に関して説明します。この2つは重要ですが、多くの点で異なります。●論理設計、機能設計、物理設計という設計の3つの異なる側面を紹介します。それぞれのシステム要素の例を挙げ、設計のビューがこれらをモデリンググするためにどのように使用されるかを説明します。●さまざまな種類の設計の側面に使用されるモデリンググ技法を、国際的なベストプラクティスであるISO/1EC/1EEE 15288に関連付けます。●これまでに紹介した設計のビューを、モデルベースシステムズエンジニアリング(MBSE)フレームヮーク、特に本書を通して開発された設計の観点に取り込みます。最後に、いくつかの演習問題を用意しており、本章の学習目標の達成を確認することができます。設計を定義するあらゆるシステムの開発に関して、ライフサイクルの初期段階で検討される3つの概念があります。●ニーズを理解するシステムの目標、能力、要求など、システムのニーズを特定することです。これに関しては、第6章「ニーズおよび要求求」で説明しました。これは、一般的にISO/1EC/1EEE 15288のライフサイクルのコンセプトステージで実施されます。2フフ●問題を理解する問題または問題領域を理解するために、システムのニーズを分析することです。システムズエンジニアリングでは、第6章「ニーズおよび要求求」で取り上げたコンテキストのモデリンググおよびシナリオのモデリンググで対応します。これは、一般的にISO/1EC/1EEE 15288のライフサイクルのコンセプトステージで実施されます。●解決策を理解するシステムのユーズを理解した結果、発生した問題を解決することです。これは、一般的にISO/1EC/1EEE 15288のライフサイクルの開発ステージで実施されます。設計は上記の3番目に該当します。問題解決には多くの方法があり、設計に適用できる技法も多く存在します。1つの問題に対して、1つの解決策だけでなく複数の解決策を検討することが重要です。そして、それらのさまざまな解決策を評価し、最も適切な解決策を選択します。このようなさまざまな解決策のことを解決策の候補(Candidate)と呼びます。解決策の候補(Candidate)は設計のどの段階でも検討することができます。本章では、設計を行う際に適用されるモデリンググ技法をいくつか紹介します。設計には、大きく分けて「アーキテクチャ設計(AК hitcctural Dcsign)」と「詳細設計(DctallcdDesign)」の2つの段階があります。アーキテクチヤ設計アーキテクチャ設計または上位設計と呼ばれるものは、主にシステムを単一の実体とみなし、それがどのようにサブシステムに分解されるかということに関係します。また、これらのアーキテクチャ設計のビューは概念的であることが多いのです。次ページのダイヤグラムは、第2章「モデルベースシステムズエンジニアリング」ですでに紹介したシステム構造ビューです。このシステム構造ビューが、アーキテクチャ設計の説明の基礎になります。りθθ
# 第7章 設計のモデリング

図7.1 ハイレベルなシステムの概念を示すオントロジー定義ビュー図7.1は、SysMLのブロック定義図を使用し、ハイレベルなシステムの概念を示すオントロジー定義ビューを示しています。アーキテクチャ設計は、主に以下から構成されます。● 1人以上の利害関係者がシステムと相互作用します。●それぞれのシステムはいくつかのサブシステムから構成され、そのうちのいくつかは所有されていますが、いくつかは所有されていません。したがつて、アーキテクチャ設計は、システムそのもの、およびそのシステムが同じ抽象度の実体(利害関係者)およびその構成(サブシステム)と相互作用する方法に主に焦点を当てます。アーキテクチャ設計は、システムそのものおよび関連するインタフェースを検討することで問題を解決します。さらに低い抽象度で適用される設計の側面は、詳細設計として検討されます。(ontology element)Stakeholder<ontology element>System<ontology element>Subsystem{ interacts withan >1¨ *ノθ/詳細設計アーキテクチャ設計がシステムそのものとそれに関連する利害関係者およびサブシステムに関わるものであるのに対し、詳細設計は、より低い抽象度のものに関係します。次のダイアグラムを見てください。図7.2 より詳細なシステムの概念を示す拡張したオントロジー定義ビュー図7.2は、SysMLのブロック定義図を使用し、より詳細なシステムの概念を示す拡張したオントロジー定義ビューを示しています。詳細設計は、それぞれのサブシステム(Subsystcm)を構成部品に分解することに関係します。この場合、アセンブリ(Assembly)とそのコンポーネント(CompOnent)に関係します。< communicateswithhai an interest in >1.「1..tdont0logY element,Syst€m(ontology elementDstakeholder{ontology element}subsystem1¨・interacts Nvith▼1..°(ontologv ele$€ntDA*eemblyt.゛interacts with▼ ，aontology elementpCornponent1¨・:減era曖5 WIth▼′θ21
# 第7章 設計のモデリング

詳細設計では、サブシステム(Subsystem)、ァセンブリ(Assembly)、コンポーネント(COmpOnent)とそれらのインタフェースを理解することに重点が置かれます。どちらの設計の場合も、以下のようなビューで設計を示します。●システム構造ビュー(System structure view)システム要素とその関係性を検討します。●システム構成ビュー(System ConfiguratiOn view)個々の構成でのシステム要素間の固有の関係性を検討します。●システム振る舞いビュー(System BehaviOr view)システム要素間の相互作用を検討します。●インタフェース特定ビュー(lnte″ ace ldentificatiOn view)さまざまなシステム要素上のポートの位置を検討します。●インタフェース定義ビュー(lntettace Definition View)個別のポートおよびインタフェースを特定します。●インタフェース振る舞いビュー(!nterface BehaviOr view)ポートおよびインタフェース間の相互作用を検討します。これらのビューは、第3章「システムとインタフェース」ですでに紹介しました。本章では、これらに加えて、機能モデリンググを目的とした新しいビューをいくつか紹介します。Jθ′(ontologY element,SyrtM(ontology element)subsystem(ontology element)Loglcal1(ontolory element,Svstem Element(ontology element)A$embly(ontology element)Funclional1.奉(ontology element)Physical(ontology element>Component(ontology elemenl)software(ontoloey element)Hardwaae▲satisfies●pe ″pe” ■▼interacts with >iS d:響edレ図7.3 システム要素の抽象型を示す拡張したオントロジー定義ビュー図7.3は、SysMLのブロック定義図を使用し、システム要素の抽象型(Absiact Type)を示す拡張したオントロジー定義ビューを示しています。図7.3から、システム要素には3種類あることがわかります。以下を見てください。●論理システム要素(Logical System E!ement)機能システム要素(Functional Systcm Elcmcnt)によって満たされます。●機能システム要素(Functional System Element)論理システム要素(Logical Systcm Element)を満たします。1つ以上の物理システム要素(Physical System Elcment)に割り当てられます。●物理システム要素(Physical System E!ement)機能システム要素(Functional System Elcment)が割り当てられます。図7.3には興味深いSysMLのモデリンググ構成要素があります。それは、システム要素から2つの特化(Specializ􈎹on)が出ているということです。通常は1つの汎化′θイ11¨，―― ―ｌ μabstract system
# 第7章 設計のモデリング

(GencralizatiOn)で結合されますが、同じモデル要素に関連する2つのまったく異なる種類の汎化(Generalization)を示すこともできます。この2つの汎化(GcncralizatiOn)は、この場合、抽象型(Abstract■ pc)とシステム型(System ttpe)という修飾語を付加することで区別することができます。これを識別器(Discriminator)といいます。したがって、図7.3は2つの異なる汎化(Gencralization)があるということを示しています。以下を見てください。●1才由象型 (Abstract Type)システム要素の抽象度にもとづき3種類のシステム要素を示します。●システム型(System Type)システム階層にもとづいたシステム要素の種類を示します。これらの識別器(Disc􈎸􈎹nator)を使用すると、親ブロックであるシステム要素(SystcmElcment)に抽象型(Absiact ttpc)とシステム型(Systcm■ pc)の2つの型を関連付けることができます。たとえば、システム要素に論理的(Logical)とサブシステム(Subsystcm)の両方の型を関連付けることができます。これにより、サブシステム(Subsystem)、ァセンブリ(Asscmbly)、コンポーネント(Component)のそれぞれを、論理的(Logical)、機能的(hnctional)、物理的(Physical)のいずれかに関連付けることができ、非常に柔軟な対応が可能になりました。この時点で強調しておきたいことは、ォントロジー定義ビューを使用して定義されたこれらの用語はモデラー次第であるということです。これは、図7.3に示されるものが、本書で使用される概念と用語の定義に過ぎないことを意味します。オントロジーは、あなた自身のニーズを満たすように定義されなければならず、あなたの組織での仕事のやり方を表現するものでなければなりません。本章では、これらを具体的に使用し、アーキテクチャレベルおよび詳細レベルで適用できる3種類のモデリンググ、すなわち論理モデリンググ、機能モデリンググ、物理モデリンググの方法を紹介します。ノθ∫論理モデノ堕要素を定義する論理モデルは、「モデルのそれぞれの要素は何か?」という抽象的な概念を示します。重要なことは、論理モデルの要素は特定の解決策に依存しないことです。次のダイアグラムを見てください。Ksul,sy“ em》饉ke RockdSYstem,“"蒸●いo:d“ 滲D"ver(lsbtyttem,ahaisls$ubnslem,DdvelnlnssbiysaemtBody({bitAtem,lnterlotdrlver >C_1図7.4 自動車システムの論理システム構成ビュー図7.4は、SysMLのプロック定義図を使用し、自動車システムの論理システム構成ビューを示しています。図7.4のそれぞれのブロックは論理要素を示しています。それぞれの論理要素は概念であり、どのような解決策からも独立しています。したがって、「ドライブトレイン(D􈎸 veTrain)」はドライブトレインの概念であって、ドライブトレインの固有の実装を意味するものではありません。これは非常に強力なモデリンググ技法であり、論理モデルは現実のプロジェクトでも非常によく使用されます。その理由の1つは、すべてのプロジエクトに適用できる共通の論理モデルをもちながら、プロジェクトごとに異なる方法で実現することができるためです。′θび
# 第7章 設計のモデリング

ドライブトレイン(Dr􈎺e Trdn)の論理システム要素は、より詳細に分解することができます。次のダイアグラムを見てください。図7.5 ドライブトレインを示す論理システム構成ビュー図7.5は、SysMLのプロック定義図を使用し、 ドライブトレイン(D􈏜e Train)を中心とした論理システム構成ビューを示しています。このダイアグラムに関しては、第3章「システムとインタフェース」で説明しましたが、論理を示すビューであること、それぞれのブロックが論理システム要素を示していることが明らかになったことから、このダイアグラムがより大きな意味をもつようになりました。しかし、「どのようにしたら、図7.5のシステム要素が、機能的または物理的ではなく、論理的であると識別できるのか?」という疑間が生じるかもしれません。これに関しては、複数のステレオタイプを使用することで非常に簡単かつ明瞭に示すことができます。次のダイアグラムを見てください。asubiyiem)ortc Trelncontrolt a$embty,cool.{, Unltdat*mbly)charger《asembly"power forl pr*ld€5{a$embly*Motot{asembly,aatte.y1 ■(a$embly$cofiburtion gnEioasalsembly,Elactric Motsd€termlnerpower ratio o,?略▼ provide, poser totv′θアcontrolsDrive lrain(Subsyrtem, logicalv( a$embly,logical,6ear 8ordasJembly,loticalDControl Unit{asssmbly.logical}Char6ercontrols一▼▲ po熙rer for(asssbly,logielrMotor(a5*mbly,logical,Batteryユ1 1( asrembly, logical tcombustios tnEineqas5€mbly,logicalt=leCtFiC Motordeterminespo$€r ratio of t黎▼1..拿1providsr power farV図7.6 複数のステレオタイプを使用してドライブトレインを示す論理システム構造ビュー図7.6は、SysMLのブロック定義図を使用し、複数のステレオタイプを含むドライブトレインを表す論理システム構造ビューを示しています。図7.6には、それぞれのシステム要素に2つのステレオタイプがありますが、これはSysMLとして正しい構文です。2つのステレオタイプは図7.3のオントロジー定義ビューで定義され、SysMLの識別器(Discnminator)にて修飾された2つの異なる特化(Specialization)に対応します。すなわち、これらのステレオタイプを見ると、 ドライブトレイン(D􈎸 vcTrain)はシステム型のサブシステム(Subsystem)であり、抽象型の論理的(Logical)でもあることがわかります。その下位のシステム要素は、システム型のアセンブリ(Asscmbly)であり、抽象型の論理的(Logical)でもあります。このようにして、ダイアグラム上のそれぞれの要素が何を示しているかを明らかにすることができます。これらの論理システム要素を使用することは、論理的なドライブトレイン(D􈏜c Train)の概念が常に同じ基本構造をもつことを意味します。ただし、これらは論理システム要素であるため、これらのブロックのそれぞれが実際のプロジェクトでどのように実現されるかを意味するものではありません。これは、参照モデル(Rcbcncc Modcl)または参照アーキテクチャ(Rcbence Architecture)として知られるものを定義するのに役立ちます。参照′θθcontrol,1
# 第7章 設計のモデリング

モデル(Rcncncc Modcl)を定義する場合、論理ビューがベースラインとなり、そこから機能ビューおよび物理ビューなどの解決策に向けたあらゆるビューを導き出すことができます。これにより、固有の解決策に特化した共通の論理要素を定義することができます。次節では、機能システム要素および物理システム要素について説明します。機能モデル要素を定義する本節では、機能モデル要素の概念について説明します。新たに導入する重要な概念の1つが機能(Function)です。機能(Function)という用語は、さまざまな領域で非常に多くの意味をもつことがあるため、ほぼすべての業界で用語の解釈についての多くの論争が起きています。機能(hnction)という用語の解釈の違いの一例を示します。以下を見てください。●入力されたパラメーターにもとづき、1つ以上の数学的演算を実行し、その結果を返す数学的関数を示します。●エンジニアリング機能、マネジメント機能、人事機能など、組織内の部門を示します。●ある人がシステムズエンジニアリング機能をもち、ビジネスにおける自分の仕事を定義するといった肩書を示します。●システム要素にて実行されるアクテイビティの単位を示します。たとえば、自動車のブレーキペダルは、ブレーキ機能を呼び出すことができます。●固有の値を返す前に、パラメーターを変換するモジュールに引き渡すようなソフトウェアの関数を示します。●パーティーまたは社交イベントを示します。すべての解釈を網羅したものではありませんが、この用語は非常に多様な意味をもつことが確認できました。′θフしたがって、ここで機能(Function)という用語を定義しますが、あなたの組織では定義が異なる可能性が非常に高いということに注意してください。本書で使用する機能(Function)の定義をオントロジーにて示します。次のダイアグラムを見てください。(ohtology elemehtDNe€dcontolOBy element)Raquirehent(ontology €lement,Functlon(ontology element,system Elqmmt < satisfies < realizes図7.7 機能の用語を導入したオントロジー定義ビュー図7.7は、SysMLのブロック定義図を使用し、本書で使用する機能(Function)の用語を導入したオントロジー定義ビューを不しています。機能(Function)は以下のように定義されています。● 1つ以上のシステム要素が1つ以上の機能を実現します機能(Function)とは、1つ以上のシステム要素の複合的な振る舞いにて実現されるある種のタスクのことです。システム要素には、サブシステム、アセンブリ、コンポーネントがあり、これらのレベルのいずれか、またはすべてに機能が存在する可能性があることを忘れないでください。● 1つ以上の機能が1つ以上の要求を満たします1つ以上の機能の組み合わせが実行されることで、システムの要求の1つ以上が満たされます。また、機能(Function)は論理的要素と同様、固有の解決策に依存しないことに注意してください。問題の固有の解決策の定義については、物理モデル要素に関する節で説明します。機能に関するオントロジー要素の新規追加は、他のオントロジーにも影響を与えます。次のダイアグラムを見てください。′/θ
# 第7章 設計のモデリング

(ontology elementDNeed(ontology element,Requlrement(ontoiogy elementtCapability(ontology el€m€nt)Goal(ontology element,Function<ontology elementrtSystem Element< satisftesrealizes1.* ■._図7.8 機能を示しニーズを拡大するオントロジー定義ビュー図7.8は、SysMLのブロック定義図を使用し、再び機能(Function)を示しニーズを拡大するオントロジー定義ビューを示しています。能力(Capあility)と目標(Goal)を含めて、第6章「ニーズおよび要求求」で定義したニーズ(Nced)の概念を拡張しました。システムに関連するビューでは、機能(Function)という概念はユーズモデリンググの世界と解決策との間に重要なつながりを提供し、より広いオントロジーにとって非常に重要なものとなっています。したがって、機能(Function)という概念は、モデル全体のトレーサビリティに不可欠な要素です。たとえば、オントロジー要素間のパスをたどることで、システム要素とすべての種類のニーズとの関係が追跡できます。たとえば、あるシステム要素とオリジナルの目標との関係性は、以下のようなパスをたどることで追跡できます。1.システム要素は機能を実現します(A System Elcment rcalizcs a Function)2.機能は要求を満たします(A Function satisncs a Requiremcnt)3.要求は能力を提供します(A Rcquircmcnt dclivcrs a Capability)4.能力は目的を満たします(A Capability meets a Goal)トレーサビリティは、システムズエンジニアリング全体に適用される非常に重要な概念であり、ISO/1EC/1EEE 15288の基本的な要求でもあります。ISO/1EC/1EEE 15288は、「すべてのニーズは、システムのライフサイクル全体にわたり、 トレーサビリティがとれていなければならない」と定めています。これもオントロジーの利点の1つです。オントロジーがあれば、システム開発全体のトレーサビリティがモデルに内在していることになります。モデリンググツールを使ってオントロジーを実装すると、 トレーサビリティが自動化されて効率化することがあります。ノ//トレーサビリティは、以下の2つの例を含むさまざまな理由から重要です。●影響分析(:mpact Analysis)ニーズから解決策への方向でトレーサビリティを適用し、ニーズの変化が解決策に与える影響を確認します。たとえば、目標の1つが変更された場合、その関連要素をモデル全体から追跡することができます。この例ではシステム要素まで追跡します。●回帰分析(Regression Analysis)解決策からニーズヘの方向でトレーサビリティを適用し、解決策の変更がニーズにどのような影響を与えるかを確認します。たとえば、あるシステム要素が変更された場合、それが関連するオリジナルのニーズ(要求、能力、日標)のいずれかにまでさかのぼることができます。また、機能(Function)はさまざまな種類のシステム要素すべてと重要な関係をもっています。次のダイアグラムを見てください。図7.9 1機能を示すシステム要素を拡張するオントロジー定義ビュー図7.9は、SysMLのブロック定義図を使用し、機能(Function)を示すシステム要素を拡張するオントロジー定義ビューを示しています。図7.9のオントロジーにより、機能(Function)の概念がシステム要素の概念と関連するようになりました。システム要素にはサブシステム、アセンブリ、コンポーネントという3つの特化(Spccialization)があり、継承の概念が適用されます。すなわち、機能(Function)とシステム要素との関係は、3つの特化(Specialization)に継承されることになります。これにより、機能(Function)は、システム要素に適用される(合成関連と集約関連で示される)H勒to蜘e●確薫ゃGFt{t, “":o ogy●en麒,●――一月1・~訓 |ノ/2
# 第7章 設計のモデリング

3つの抽象化レベルのいずれにも適用できることが推測されます。機能(Func● on)という用語がいずれのシステム要素の階層にも適用可能であることが多少の混乱につながるかもしれません。なぜなら、ここで機能(Funcion)という用語を使用する場合、それがシステム要素階層のどのレベルに適用されるかを明確に示さなければならないためです。これは、ダイアグラム上で暗黙的に達成されるかもしれませんじ、機能(Function)の構造を考慮するときに明示的に達成されるかもしれません。機能の整造重皿亘二定墨立登概念の定義が暗黙的に示される場合、人々がそれぞれの思い込みでモデルを判断するようになります。そのため、概念は可能な限り明示的に定義されるべきです。機能とシステム要素の関係性をモデルで表現する方法は2つあります。次のダイアグラムを見てください。図7.10 割り当てを使用して明示的な関係性を示す機能割り当てビュー図7.10は、SysMLのブロック定義図を使用し、割り当てを使用して明示的な関係性を示す機能割り当てビューを示しています。図7.10には、2つのステレオタイプを使用して修飾されたブロックがあります。以下を見てください。● くくassembly>>システム要素の一種で、機能を割り当てる所有ブロックを示します。ここでは、電気モーター(Elcctric Motor)プロックに<<assembly>>のステレオタイプを適用しています。0)くくfunction>>実際の機能を示し、ステレオタイプが付与されたSysMLブロックとして表現され、フア′《func■on》start lmotor(assem bly, logical )Electric_Motor(allocate)) <functionlstop_motor<<assembly>>が付与された所有ブロックに割り当てられます。ここでは、「モーターを起動する(st激_motor)」ブロックおよび「モーターを停止する(stop_motor)」ブロックにく<function>>のステレオタイプを適用しています。機能とアセンブリは、SysMLの構成要素である割り当て(AHocation)を使用して関連付けられます。SysMLでは割り当て(Allocation)を依存関係(Dependency)で表現し、<<a1locate>>のステレオタイプを適用します。この方法は、システム要素(この場合はアセンブリ)への機能の割り当てを明示的に示すのに非常に適した方法です。しかし、それぞれの機能をブロックとして表現するため、機能の数が多い場合、ダイアグラム上でく<function>>ブロックでスペースを占めることになり、非常に煩雑になることがあります。そこで、機能とシステム要素の関係性をモデルで表現する別の方法を紹介します。次のダイアグラムを見てください。図7.11 機能区画を使用して明示的な関係性を示す機能割り当てビュー図7.11は、SysMLのブロック定義図を使用し、機能区画を使用して明示的な関係性を示す関数機能割り当てを示しています。図7.11は、図7.10と同じシステム要素と同じ機能を示しています。すなわち、アセンブリの電気モーター(Elcctnc Motor)に、「モーターを起動する(start motor)」機能および「モーターを停止する(stop_motor)」機能が割り当てられています。機能の割り当てがステレオタイプとブロックとの関係性で示されるのではなく、所有ブロック上にく<function>>というステレオタイプで独自の区画が与えられています。この方法により、ダイアグラムが占めるスペースが大幅に削減されたことに注目してください。アセンブリのペダル(Pedal)と制御装置(Co山ol Unit)が追加されていますが、ダイアグラムが占めるスペースは図7.10よりも小さいのです。薇aSSemb壌|。g鶯倉:"pedal(functionDpre5'_accelerator{lrclease_accelerator{}apply_brake{}release-brake{}“aSSembMbgi鑢1'〔:oct轟o Motor(fun€tion,start_rnoto()rtop_moto()“aS鯰鶴bVbgi鮨l"Gontro;U,itsirndion*calculate_speed{}che**speed(!apply*powe()recharge batterdlJノイ
# 第7章 設計のモデリング

それぞれの表現方法に長所と短所がありますので、どちらの表現方法を選択するかはモデラーの判断次第です。●依存関係(Dcpendency)の一種である<<allocate>>を使用することで、割り当てがはるかに視覚的になり、印象に残ります。また、必要であれば機能間の関係を示すこともできます。たとえば、機能の振る舞いを定義する際にさまざまな機能間の依存関係を示すこともできます。●<<ftlnction>>の区画を使用することで、ダイアグラムが小さくなり洗練されると言えるかもしれません。もう1つの方法と比べると、1枚のダイアグラムに多くの割り当てを表示することができます。機能の構造的側面が定義されましたので、次節では機能の振る舞い的側面を定義します。機能の振る舞い的側面の定義本書を通して推奨してきたモデリンググの標準的な方法は、常に構造的側面と振る舞い的側面の両方を考慮することでした。これまでは機能の正確な意味を定義し、機能を異なる抽象度のシステム要素にどのように割り当てるかという構造的側面について検討してきました。次のステップでは、機能の振る舞い的側面を検討することにより、機能が互いにどのように相互作用するかを確認します。機能の振る舞い的側面には、第5章「システムズエンジニアリングプロセス」で初めて紹介したSysMLのアクティビティ図を使用します。これを説明するために、図7.11の中で多くの機能をもつアセンブリのペダル(Pedd)を見てみましょう。次のダイアグラムを見てください。ノ/∫pre$r_acael€}ata{Pedal::}(pedal::)apply-brake(pedali:)図7.12 システム要素ペダルの機能間の相互作用を示す機能振る舞いビュー図7.12は、SysMLのアクティビティ図を使用し、システム要素であるペダル(Pedal)の機能間の相互作用を示す機能振る舞いビューを示しています。図7.12のそれぞれの機能の基本的な実行の流れは以下の通りです。1.最初の機能は「アクセルを踏む(pres亀acce!erator)」です。2.その直後に必ず「アクセルを離す(release_accelerator)」必要があります。3.1度アクセルを離すと、「アクセルを踏む(press_accelerator)」、「ブレーキをかける(app!y_brake)」の2択になります。4.「ブレーキをかける(apply brake)」の直後に必ず「ブレーキを離す(release_brake)」必要があります。1度ブレーキを離すと、「アクセルを踏む(press_accelerator)」、「ブレーキをかける(app!y_brake)」、もしくはダイアグラムを終了すノ/6chek-sFld{Pedal:, (Control Unjti, Unitij){Control Unit:Jrol€e-accolerator{Pedal:r)aPply-brake{co.trol Unit.:)lPedal:r)
# 第7章 設計のモデリング

るという3択になります。この機能振る舞いビューは、ペダル(Pedal)のシステム要素のブロックにのみ適用され、モデリンググとしては、まったく問題ありません。ただし、機能振る舞いビューは、SysMLのスイムレーンを使用することでさまざまなシステム要素にまたがる機能割り当てを示すよう拡張することができます。次のダイアグラムを見てください。図7.13 複数のシステム要素にまたがる機能間の相互作用を示す機能振る舞いビュー図7.13は、SysMLのアクティビティ図を使用し、複数のシステム要素にまたがる機能間の相互作用を示す機能振る舞いビューを示しています。図7.13では、図7.11で示した3つのアセンブリのシステム要素をSysMLのスイムレーンで表現しています。それぞれのスイムレーンには、関連するシステム要素であるペダル(Pcdal)、電気モーター(Elecdc Motor)、制御装置(Co前ol Unit)が示されています。重要なことは、それぞれの機能が適切なスイムレーンに示されていることです。これにより、異なるシステム要素間の機能の流れが1つのダイアグラム上に表現されます。図7.12と図7.13の違いを確認してみましよう。以下を見てください。●図7.12のように1つのシステム要素を考える場合は、そのシステム要素内の機能のフローしか示せません。したがって、フローが「アクセルを踏む(press_accelerator)」′/アから「アクセルを離す(release_accelerator)」に直接向かうことになります。●図7.13のように複数のシステム要素にまたがる機能のフローを考える場合は、異なるシステム要素からの機能間のフローがわかりやすくなります。すなわち、「アクセルを踏む(press_acce!erator)」からの流れは、制御装置(Control Unit)のシステム要素に割り当てられている機能である「速度を確認する(check_speed)」に向かいます。機能モデリンググについても、やはり特定の解決策に依存しないものであるべきです。これについては、次節の物理的モデリンググでさらに説明します。物理モデル要素を定義する物理モデルでは、モデルのそれぞれの要素が現実の物質を具体的に表現します。論理システム要素と機能システム要素の両方が概念的な世界に存在するのに対し、物理システム要素は現実的な世界を示します。論理システム要素と機能システム要素を定義しているときは、適用できる具体的な技術や技法により、さまざまな方法で実現できる概念的な問題解決策を検討していました。物理システム要素の場合には、固有の技術や技法を使用しながら、現実の固有の問題解決策を検討します。堕哩正三菫上医憂三整型⊇三∠丞二L△重宣生:五ΞLと≧生2主主」塾これを説明するために、電気モーター(Elcc􈎹 c Motor)のシステム要素の構造を検討します。ここまでは、電気モーター(Electnc Motor)の論理システム要素を検討してきましたが、物理システム要素を検討することもできます。次のダイアグラムを見てください。′/∂
# 第7章 設計のモデリング

“o郷cmbl"physI"1静EledvicIMk戯o『“嗜‐sltdes into鷲assemb:γ ,physlcal)stator “aSSemblγ ,pれYSical"穐otor図7.14 電気モーターの構造を示す物理構造ビュー図7■ 4は、SysMLのプロック定義図を使用し、電気モーター(Elecmc Motor)の構造を示す物理構造ビューを示しています。図7.14にはいくつか興味深い点があります。以下を見てください。●システム要素に異なる2つの型を適用するため、複数のステレオタイプが使用されています。これらはSysMLの識別子として定義された型です。●電気モーター(Elcc􈎹 c Motor)のステレオタイプが、くくassembly>>およびく<physical>>となつていることに注目してください。図7.10ではく<assembly>>およびくく10gical>>となっています。これはモデリンググの観点からはまったく問題ありませんが、図7.10と図7.14に登場する電気モーター(Elec􈎹 c Motor)は別のモデル要素でなければなりません。多少混乱を招くかもしれませんが、異なるステレオタイプが適用された同じ名前の2つのモデル要素が存在することになります。●くくassembly>>とステレオタイプされたブロックがあり、同じく<<assembly>>とステレオタイプされた他の2つのブロックから構成されています。これは、アセンブリからそれ自身への合成関連(Composite)、集約関連(Aggrcgadon)、または両方を必要とするため、実際には元のオントロジーに準拠していません。これは、システムのモデリンググの適用を反映するために、オントロジーが時間とともに発展していくという良い例です。図7.14は、次のように読むことができます。l A slidcs into B:AがBにスライドするノ/フ● 電気モーター(E!ectric Motot)は、1つのステーター(Stator)と1つの回一ター(Rotor)から構成されています。●ローター(Rotor)はステーター(Stator)にスライドします。3つのブロックはすべて、アセンブリである物理システム要素を示しています。それぞれのブロックは物理的なアセンブリなので、これは現実の電気モーターを示す実際の解決策です。ステレオタイプは、これが論理的なモデルではなく、物理的なモデルであることを伝えています。論理的ではなく具体的な解決策であるということは、ステーターとローターをより詳細に分解する場合、より詳細な物理システム要素も扱えることになります。次のダイアグラムを見てください。■…。〈`aS●emOiY′ phVSio尋1■Rotoris placed oneach side of bト{component, physic$l,Rotor corEscomponent, ph$ic*lDfnd Ringcc6mp6nent, phvtiial$Str€l Lemlnafionqcomponeilt, physicatshod《comp●nent′ phv,OcaI"SI●tcentre of is placed alonElside F1,`ホ1図7.15 ローターのアセンブリの物理構造ビュー図7.15は、SysMLのブロック定義図を使用し、ローターのアセンブリの物理構造ビューを示しています。図7.15のシステム構造ビューは、ローター(Rotor)のアセンブリ(Assembly)を構成要素に分解することに焦点を当てています。また、これらの構成要素は物理システム要素でもあります。これは、それぞれのブロックに2つのステレオタイプを適用することで、2 A is placed on each side of B:AはBの両イ則に配置されるノ2θ
# 第7章 設計のモデリング

ブロックが何を表現しているかを正確に示しています。図7.15は、以下のように読むことができます。●ローター(Rotor)は、2つの終端リング(End Ring)と1つのローターコア(RotorCore)から構成されます。● 2つの終端リング(End Ring)は、回―ターコア(Rotor Core)の両側に配置されています。●ローターコア(Rotor Core)は、1つのロッド(Rod)、1つ以上のスチールラミネーション(Steel Lamination)、1つ以上のスロット(Slot)から構成されます。●ロッド(Rod)は、1つ以上のスチールラミネーション(Steel Lamination)の中心を貫通します。●それぞれのスチールラミネーション(Steel Lamination)は、ス回ット(S!ot)に沿って配置されます。固有の数値ではなく多重度で1..*を使用しており、合成関連(Compositc)のブロックの正確な数に関して、システム構造ビューは不正確であることに注意してください。また、関係性はブロック間のインタフェースを明示的に示すものではありませんが、関係性とインタフェースは一貫性をもちます。インタフェースとブロックのインスタンスの固有の数は、次節で構成ビューを作成するときに検討します。別のアセンブリであるステーター(Stator)の構成図を示します。次のダイアグラムを見てください。′2/(component.physicalDStator(component.physica,)Conducting Wire End Be:l《component.physicaい (component.physical >st● t●,core(component,physical DF ame1´●1'Sis placed in )aroundPhase 3(component.physical, (component.physical,Phate 1(component.physical,Phase 2(component.physical)1_ウIS Ia‖|『tedレ iS i驚撮tedレ図7.16 ステーターのアセンブリの物理構造ビュー図7.16は、SysMLのプロック定義図を使用し、ステーターのアセンブリの物理構造ビューを示しています。図7.16でも、複数のステレオタイプを使用し、すべてのシステム要素が物理的であり、アセンブリとそれに関連する複数のコンポーネントが存在することを示しています。図7.16は、以下のように読むことができます。●ステーター(Stator)は、1つのステーターコア(Stator Core)、1つのフレーム(Frame)、1つ以上の導線(Conducting Wire)、2つの終端ベル(End Be‖ )から構成されます。●ステーターコア(Stator Core)は、フレーム(Frame)に配置され、1つ以上のリング(Ring)から構成されます。●それぞれのリング(Rhg)は、他のリング(Ring)と1つ以上積層され、また他のリング(Ring)から1つ以上絶縁されています。●リング(Ring)には、導線(Conducting Wire)を巻きつけます。●導線(Conducting Wire)には、第一相(Phase l)、第二相(Phase 2)、第二相(Phase3 A is placedin B:AはBに配置されるA is wrappcd around B:AをBに巻きつけるA is lamnated with B:AはBと積層されるA is insulated from B:AはBから絶縁されている′22
# 第7章 設計のモデリング

3)の3種類あります。図7.16の物理構造ビューは簡単に理解できそうですが、このビューには見直すべき点があります。どのようなビューを確認するときでも、そのビュー自体に問題がないか確認することが重要です。この場合、終端ベル(End Bcn)を考えてみましょう。合成関連(Compositc)を除けば、ダイアグラム上の他の要素とは何の関係もないことに気づきます。これはどの要素とも異なる特徴であるため、疑ってかかるべきです。多くの場合、他のブロックと関連をもたないブロックは、関係性が欠けていることを示します。この場合、終端ベル(End Ben)とリング(Ring)の間には関連性があるべきです。このようなモデリンググ上の問題に注意し、常に疑間をもつことが重要です。そのような質問に答えることはモデラーの責任であり、批判ではなく建設的なフィードバックとして捉えるべきです。日標は正しいモデルを完成させることであり、プロジェクトが進むにつれてモデルは発展していくため、どんなダイアグラムについても自問自答をすることが、モデルの内容が正しいことを確認する良い方法であるということを忘れないでください。物理モデル要素の構成をモデリンググする前節にて、システムの一般的な構造のモデルが完成したため、解決策に向けた固有の構成のモデリンググを開始することができます。構成のモデリンググという考え方は、第3章「システムとインタフェース」で紹介しましたが、物理的なモデリンググを考えるとき、それぞれの構成がシステムの固有の解決策を示すことになります。次のダイアグラムを見てください。ノ2′(componentt <compcnenttBcar: End Ring(componentDL.rfrlntlron-l: Lemlnation(componentDLrmlnqtlon-Z: Lrmltra$on: Rotor CorG(compon€ntDcassemblyrSlmph! nstot図7.17 2枚のラミネーションをもつ単純なローターの物理構成ビュー図7.17は、SysMLの内部ブロック図を使用し、単純なローターの固有の構成を示しています。図7.17が、図7.15で示したローターのアセンブリの物理構造ビューと一致していることに注目してください。この例では、Simple:Rotorと定義されたアセンブリのパート名で示された単純なローターを示しています。図7.17は、2枚のラミネーションをもつローターを示しています。物理構成ビューは、複数の異なる構成を定義することができる便利な仕組みです。これらの異なる構成は、異なる解決策の候補となる可能性があります。この場合、解決策の候補は単純に異なる構成で表現されることもあれば、異なるシステム要素を使用したまったく異なる構造で表現されることもあります。次のダイアグラムを見てください。′2イ(componentD(flow type port)RotorPort:Magnetic Porttront: EndRingMechanicalPortent)port)<flow“cornponent》:Stoti241《con、ponent〉〉Stee:Lamination[24](component,(flow type port) slotPort:Meahanical Port(flow type port)Mechanical PortMechanical Port(flow type port)(componentn: Rotor Core(flow type port) RodPort:Mechanical PortRear:EndRing(flow typeport)MechanicalPortRotorPortl:Mechanical<assembly>Multiple: Rotor(flow type port)RotorcorePortiMagnetic Port《10ヽA′typeport》(flow typeport)MechanicalPort
# 第7章 設計のモデリング

図7.18 複数のラミネーションをもつ複雑なローターの物理構成ビュー図7.18が、図7.15で示した物理構造ビューと一貫性をもつことに注目してください。これは、同じ物理構造ビューをもちながら、それに関連する物理構成ビューを使って複数の構成をもつことができることを示しています。これにより、複数の解決策の候補を示すことができます。また、この複雑な構成について興味深い点があります。以下を確認してください。●コンポーネント(Component)のパートの多重度:Slot、:Steel Lamination、:Rodのコンポーネントに関連する多重度が[24]であることに注目してください。これは、複数のパートがあることを明示的に示さなくても、実際に複数のパートがあることを示すことができる便利な仕組みです。これは、複数の要素を1つのビューに表示すると、ビューがあまりにも複雑になり読みにくくなるため、それを簡略化して表示する方法と考えることができます。●ポートの定義このビューでは、ポート定義にその型と名前が表示されています。これにより、ビューノ2∫図7.18は、SysMLの内部ブロック図を使用し、複数のラミネーションをもつ複雑な構成のローターの物理構成ビューを示しています。に詳細が追加されますが、複雑になり読みにくくなる可能性があります。いずれもモデラーのスキルと判断がいかに重要かを示しています。どのようなビューでも視覚化することを考えるとき、どの利害関係者がそのダイアグラムを読むかを考えることが重要です。たとえば、エンジニアが見るのであれば、図7.18のように詳細を表示する方が適切かもしれませんし、単純さを好むマネジャーが見るのであれば、図7.17のように単純な表示をした方がよいかもしれません。モデラーの裁量にもよりますが、いずれにせよ、十分な情報にもとづいて判断することが重要です。システムの振る舞いを定義するここまでは構造ビューに焦点を当ててきましたが、構造と振る舞いの両方を考慮することが重要です。これは本書のテーマの1つでもあります。システム要素とその構造を示すビューがある場合、特に固有の構成がある場合には、これらの異なる構成に関連するいくつかの振る舞いを示すことが重要です。次のダイアグラムを見てください。《assembly》Pedai(assembly)Control Unit《assenlbly)〉MotOrpreSS_aCCelerat。「()release_accelerator( )apply_brake()図7.19 ブレーキのシナリオを示すシステム振る舞いビュー図7.19は、SysMLのシーケンス図を使用し、ブレーキのシナリオを示すシステム振る舞いビューを示しています。′2び
# 第7章 設計のモデリング

ここに示すようなシステム振る舞いビューは、ほぼすべての構造ビューに適用できるため、非常に柔軟で強力です。たとえば、ここでの例は図7.10と図7.11で説明した論理アセンブリに関連していますので、振る舞いは論理アセンブリに関連するものです。しかし、同じ種類のビューであるシステム振る舞いビューは、図7.17および図7.18のような物理構成ビューにも同じように簡単に適用することができます。これは、このビューがいかに柔軟であるかを示しており、異なるビュー間の一貫性を示す良い例となります。これまで説明してきたビューは、モデリンググのグッドプラクティスを使用してきました。ここで、ISO/1EC/1EEE 15288の設計のアクティビティに関するプロセスを確認することで、このモデリンググが国際的なベストプラクティスとどのように関連しているかを確認します。ベストプラクティスの_プロセス」こ準拠する本章でこれまで検討してきたアーキテクチャ設計および詳細設計にモデルベースを適用する技法は、国際的なベストプラクテイス、この場合ISO/1EC/1EEE 15288「ソフトウェアおよびシステムズエンジニアリングのライフサイクルプロセス」に準拠するために使用することができます。ここで注目すべきは、技術プロセスグループの中のアーキテクチャ定義プロセス(Architccture Dennition Process)および設計定義プロセス(Dcsign Dcnnition Process)の2つです。それぞれについて次節で説明します。|〔:ii」:::≧ Z:1[::::(:】Zil[:::_::::」:::_二]1__1::ii」2」:::!」::||:__1111:2.::::::_:::::::_::i:L_::i:::::_111::Li:1:::_:11::IL:i:i::!:_::::i::1_:::::1:|_::::lil!::::_1:::!|、|__11::::L::!i:::::lll![!:::::!::二::::::Lアーキテクチャ設計に関連するISO/1EC/1EEE 15288のプロセスは、アーキテクチャ定義プロセス(Architecturc Dcnnition Proccss)です。これを、第5章「システムズエンジエアリングプロセス」に記載されたアプローチにてモデリンググします。次のダイアグラムを見てください。′2/( process))Architecture Defi nition Process(outcomeDAlignment of architecture with requirementsArchitecture basis for processArchitecture candidateArchitecture viewpointArchitecture modelContextConceptEnabling systemStakeholder concern mapSystem element and interfaceTraceability(activity))Assess architecture candidates0Develop architecture viewpoints0Develop models and views of candidate architectures{)Manage the selected architecture$Prepare for architecture defi nition0Relate the a.chitecture to designfi図7.20 1SO/1圧C/IEEE 15288のアーキテクチャ定義プロセスのプロセスコンテンツビュー図7.20は、SysMLのブロック定義図を使用し、ISO/1EC/1EEE 15288のアーキテクチヤ定義プロセス(Architccturc Dein􈎸 on Proccss)のプロセスコンテンツビューを示しています。標準的なSysMLを使用して、プロセスパースペクティブのオントロジー概念を表現しています。以下を見てください。●ブロック名はプロセス名を示します。●中央の区画は、プロセスに関連する成果を示し、ステレオタイプ化されたSysMLのプロパティとして表現されます。●下の区画は、プロセスに関連するアクティビティを示し、SysMLのオペレーションとして表現されます。これまで説明した通り、ISO/1EC/1EEE 15288のプロセスに関連する成果はビューに関連付けられます。●アーキテクチャと要求の整合(A‖ gnment of archlecture with requirements)アーキテクチャ設計のビューからニーズヘのトレーサビリティを確立することに関係しています。オントロジーが存在するため、このトレーサビリティはモデルに内在しています。′2θ
# 第7章 設計のモデリング

●プロセスのためのアーキテクチャの基礎(Architecture basis for process)ライフサイクル全体にわたる、他のすべてのプロセスと統合できるアーキテクチャ設計のプロセスを確立することに関係します。この場合も、「プロセスモデリンググヘの7つのビューによるアプローチ(Seven―Ⅵews Approach to PЮ cess Modeling)」を使用して固有のプロセスを定義し、ベストプラクティスに関連付けします。これについては、
# 第7章 設計のモデリング

本書でこれまで説明したすべてのモデリンググが、全体的なアーキテクチャ定義のために使用されていることに注目してください。ここで「1枚のスライドのMBSE(MBSE in aslidc)」をもう一度確認してみましょう。次のダイアグラムを見てください。図7.21 MBSEの再検討図7.21は、第2章「モデルベースシステムズエンジニアリング」で紹介したMBSEフレームヮークを示しています。第2章では固有の表記法を使用せずに示しましたが、ここではSysMLのブロック定義図を使用して示します。ISO/1EC/1EEE 15288のアーキテクチャ定義プロセスに関連するすべての情報は、MBSEに簡単に関連付けることができます。実際、図7.21の中のモデル(Model)という単語をアーキテクチャ(Architccturc)に置き換えることで、プロセスとして実施する必要がある内容を完璧に視覚化することができます。これは、アーキテクチャとMBSEがいかに密接に関係しているかを示しています。すべてのアーキテクチャがモデルであるのに対して、すべてのモデルがアーキテクチャであるわけではないことを忘れないでください。そのため、アーキテクチャ定義にとって、モデリングは不可欠です。アーキテクチャ設計のアクティビティにおいてモデリンググが不可欠であるのと同様に、詳細設計においてもモデリンググは不可欠です。次節にて詳細を説明します。|::::i」1:::!!プ11_1!:::」1:::)∠ :!_1::::_1::::_ll:::____:1__1::11_1!::!|」:::ll」:::1__1lil::〕!_i::li:l::::::::llllili:::::ii:il::_:::::!::_1!::::1_:::l::::!:_」::::ζ _1[:::::_1::!i::::」1111111[::::11:::_:il:::≧ _詳細設計に関連するISO/1EC/1EEE 15288プロセスは、設計定義プロセス(Dcsign′ノ/Dennition Proccss)です。これを、第5章「システムズエンジニアリングプロセス」に記載されたアプローチにてモデリンググします。次のダイアグラムを見てください。( process)Design Definition Process《outcorne》AIlocated system requirementsAssessed design alternativeDesittn artifactDesign characteristics for system elementDesign enablerEnabling systerninterfaceTraceability<activityuAssess alternatives for obtaining system elementsfiEstablish design characteristics and enablers for system elementsflManage the design{)Prepare for design definition0図7.22 1SO/IEC/IEEE 15288設計定義プロセスのプロセスコンテンツビュー図7.22は、SysMLのブロック定義図を使用し、ISO/1EC/1EEE 15288の設計定義プロセス(Dcsign Dennition Proccss)のプロセスコンテンツビューを′]ヽしています。これまで説明してきた通り、ISO/1EC/1EEE 15288のプロセスに関連する成果はビューに関連付けられます。●割り当てられたシステム要求(A‖ ocated system requirements)すべてのシステム要素は、オリジナルのニーズに割り当てられなければなりません。これはトレーサビリティの実践です。繰り返しになりますが、すべてのシステム要素とさまざまな種類のニーズとの間のトレーサビリティが確立されなければならず、それらはフレームワークにて定義されます。●評価された設計の選択肢(Assessed design alternatives)複数のアーキテクチャの候補を評価しなければならないのと同様に固有のシステム要素についても複数の設計候補があり得ます。この場合も、これらを評価し、望ましい設計を選択する必要があります。●設計成果物(Design a􈎹 fact)詳細設計のあらゆる側面を示すビューの総称です。これらのビューについては、本章と第3章「システムとインタフェース」の両方で説明しています。ノ′2
# 第7章 設計のモデリング

●システム要素の設計特性(Design characteristics for system elements)それぞれのシステム要素には、関連した設計特性をもつ場合があります。たとえば、パフォーマンス特性、品質特性、環境特性などです。これらの種類の特性は見慣れた用語のようですが、これには理由があります。これらの特性は、ニーズモデリンググの際に特定された制約条件から直接導き出されています。すべての詳細設計のビューはニーズにさかのぼることができるため、フレームヮークに含まれるトレーサビリティを使用し、どの制約がどのシステム要素に適用されるかを確認することが比較的容易にできます。これについては第6章「ニーズおよび要求求」で詳しく説明しました。●設計イネーブラー(Design enablers)設計イネーブラーには、固有の設計関連活動に必要または推奨される固有の方法論、技法、表記法、ツール選択が含まれます。●イネーブリングシステム(Enab‖ ng systems)これは前節のアーキテクチャ定義プロセスの内容とほぼ同じです。あるシステム要素と相互作用する固有のイネーブリングシステムを特定し、システム要素自体を設計できる程度にモデリンググしなければなりません。●インタフェース(lnterfaces)システム要素間のインタフェースと、それを実現するシステムの外部インタフェースを特定および定義し、その接続を定義しなければなりません。インタフェースについては、第3章「システムとインタフェース」で詳しく説明しました。● トレーサビリティ(Traceab‖ ity)トレーサビリテイはフレームヮークに含まれており、すでにフレームヮークにて実現されています。プロセスで特定されたアクティビティはモデリンググのアクティビティに関連付けられます。以下を見てください。●システム要素を取得するための選択肢の評価(Assess alternatives for obtaining systemelementS())システム要素のための候補となるさまざまな解決策の評価に関係します。●システム要素に関連する設計特性と設計手段の確立(Estab‖sh design characteristicsand enablerS fOr SyStern elenlentS())システム要素に適用しなければならないさまざまな制約を特定することに関係します。●設計の管理(Manage the deslgno)プロジェクトのライフサイクルにて、詳細設計のビューを管理、設定、統治するために必要なプロセスに関連します。●設計定義の準備(Prepare for design definitiOnO)詳細設計のためのオリジナルのコンテキストと、それがどのように評価され定義され′′ノるかを保証します。また、イネーブリングシステムを含む利害関係者を十分に理解し、詳細設計を開発できるようにすること、使用する固有のッールと表記法を特定することも含みます。本章で説明してきたアプローチ全体が、ISO/1EC/1EEE 15288という国際的なベストプラクティスに適合していることを示してきました。これまで紹介したビューは、フレームヮーク全体の一部として定義される必要があります。次節では、既存のフレームワークのビューに、アーキテクチャ設計および詳細設計のビューを追加しています。フレームワークを定義するこれまで作成したビューは、第2章「モデルベースシステムズエンジニアリング」で詳しく説明した「1枚のスライドのMBSE(MBSE in a slide)」の中央部分を示したものです。それぞれのビューはSysMLを用いて視覚化されており、これは「1枚のスライドのMBSE(MBSE in a slidc)」の右側部分を示したものです。これらのビューを組み合わせることで全体的なモデルとなりますが、これらのビュー間で一貫性をもつことが重要です。一貫性がなければ、それはビューではなく単なる画像です。すべてのビューの定義は、フレームワークに取り込まれることが重要となりますが、それが「1枚のスライドのMBSE(MBSE in a slide)」の左側部分に相当します。フレームヮークは、オントロジーとビューポイントから構成されます。本節の目的は、これらのビューポイントが正しく定義されていることを徹底的に確認することです。フレームワ―クでのビューポイントを定義する
# 第7章 設計のモデリング

きます。●なぜそれぞれのビューは必要ですか?ビューポイントコンテキストビュー(Ⅵewpoint Context View)を使用して回答することがで｀きます。●それぞれのビューの構成および内容はどのようなものですか?ビューポイント定義ビュー(Viewpo􈏗 Dcnn􈎸 on Ⅵew)を使用して回答することができます。●どのようなルールが適用されていますか?ルールセット定義ビュー(Rulcsct Dcin􈎸 on Ⅵcw)を使用して回答することができます。フレームヮークが定義できたと主張するためには、上記の質問に回答できなければなりません。これらの質問は、「アーキテクチャフレームヮークのためのフレームヮーク(■amcwork br AК hitccturc Framcworks:FAF)」(Holt&Pcrry 2019)と呼ばれる特別なビューのセットを使用して回答することができます。ここでは単純に、それぞれの質問に回答するための固有のビューを作成すると考えてください。以降の節でそれぞれのビューについて説明します。フレームワークコンテキストビューを定義するフレームヮークコンテキストビュー(Framework Context Ⅵew)は、フレームヮーク全体が必要な理由を示します。フレームヮークに関心をもつ利害関係者を特定し、それぞれの利害関係者がフレームヮークからどのような利益を得ることを望んでいるかを明らかにします。●●mp:yw"hstandardsMust bc modelbesedSupport detalleddesはn Provide desiFcapabilitySuppod＼ ｀ヽcoilpliane withneeds(concean,Demmtnte(conc€rn,Defire @ndhtesolutonalJMeEt.ndenabllng iystemsA55€5s candidatesotutions“,t● 0晟MBSE th.mpion傘八ｅｈｏ‐ｄｅＦ』StandardCuSoffiDdiSn Engin3er図7.23 設計フレームワークのフレームワークコンテキストビューノノ∫図7.23は、SysMLのユースケース図を使用し、設計フレームワークのフレームヮークコンテキストビューを小しています。
# 第7章 設計のモデリング

を実施し、解決策を比較できることも必要です。これは、評価が公平で、ニーズモデリングの際に検討されたすべての基準をカバーしていることを確認するための仕組みです。●どのようなレベルの設計であれ、重要なことは「インタフェースを定義する(Definehteraces)」ことです。これはアーキテクチャ設計と詳細設計の両方で重要です。対象システムの境界の外部で何が起こつているかを考慮しなければ優れた解決策を定義することはできませんが、これは「イネーブリングシステムを理解する(Understandenab‖ ng Systems)」にて達成されます。これにより、システムのより広いコンテキストを理解し、あらゆるイネーブリングシステムと統合する設計を開発することができます。●最後に、ライフサイクルのどの時点においても、「ニーズヘの準拠を実証できる(Demonstrate comp‖ ance with Needs)」ことが不可欠です。これは、成功するシステムを実現し提供するための核心であり、システムズエンジニアリングの主要な目標でもあります。図7.23は、SysMLのそれぞれのユースケースが関心事(Concem)としてステレオタイプ化されていることに注目してください。関心事(Conccm)は、特にフレームヮークまたはそのビューポイントの1つに関連するニーズです。オントロジー定義ビューを定義するオントロジー定義ビュー(Ontology Dennition Vicw)は、フレームヮークに関連するすべての概念と関連する用語をオントロジーとして取り込みます。図7.2で設計に関係するビューのオントロジーを定義しましたが、実はこのビューがオントロジー定義ビューです。このビューで示されるオントロジー要素は、本章でこれまでに示したビューで使用されたあらゆるステレオタイプを提供しています。他の章で説明した通り、関連するオントロジー要素は、しばしば1つのパースペクテイブ(Perspcctive)として集められます。本章では、設計に関連する新しいパースペクティブ(Perspective)が作成されました。ビューポイント関係ビューを定義するビューポイント関係ビュー(Ⅵcwpoint Rel􈎹 onship Ⅵcw)は、必要なビューおよびその定義を含むビューポイントを特定します。ビューポイントは、ビューのテンプレートと考えることができることを忘れないでください。これらのビューポイントは、共通のテーマをもつビューポイントの集合であるパースペクティブ(Pcrspective)にまとめられます。Jフア本節では、設計に関連するビューを定義することに焦点を当てているため、設計パースペクティブ(Dcsign Pcrspcctivc)を作成します。これまで説明してきたビューの関係性は次のダイアグラムの通りです。6per9pectivetDeskn Persp.ittue“uewpoint"Lo3:“IS,tem StructureVettdnt鍮，ｍ 螂赫􈎼 ・“‘ いViewpd蔵・Ю瀑ゆ”動Ｗ　ｎ縫詭鷲　 撻』褻ewpoint，面掟嘔破お響麒ね０や薦Vewpoint!viewpolnuPhyskal system Con&ulationvlsrpoint`􈎼ewpolnt""St崚諄鑽Pha􈎼OFヽreW< sho'rrs how to raalize1.ド1.,1..・▲ 1ShOWS角:,CttO●5configuration of おr1..1,.3 1`鮨“rha摯。「▲show a"SI鵬腱機vbrfor図7.24 設計パースペクティブのビューポイント関係ビュー図7.24は、SysMLのプロック定義図を使用し、設計パースペクティブのビューポイント関係ビューを示しています。設計パースペクテイブ(Design Perspective)はステレオタイプく<perspective>>が付与されたSysMLのパッケージとして示されます。ここでは6つのビューポイントを定義しています。実際にはさらに多くのビューポイントが考えられますが、それに関しては6つの基本的なビューポイントの説明の後に述べます。4 A shows functionsおrB:AはBのために機能を示すA shows behavior of B:AはBの振る舞いを示すA shows how to realize B:AはBの実現方法を示すA shows a possible conngШ ttion of B:AはBの可能な構成を示すA shows a possible behaviorおrB:AはBのための可能な振る舞いを示すノ′∂
# 第7章 設計のモデリング

●論理システム構造ビューポイント(Logicai System Structure Viewpoint)上位の論理システム要素とその基本的な関係性を示します。●機能割り当てビューポイント(Funclon A‖ ocation Viewpoint)重要な機能を特定し、抽象度の異なるさまざまなシステム要素に割り当てます。●機能振る舞いビューポイント(Funclon Behavior Viewpoint)固有の機能を分解し、その振る舞いを記述します。●物理構造ビューポイント(Physical Structure Viewpoint)物理的なシステム要素を使用して、さまざまな機能を実現する方法を示します。●物理システム構成ビューポイント(Physical System Configuration viewpoint)固有の物理システム要素について、さまざまな構成を示します。●システム振る舞いビューポイント(System Behavior Viewpoint)それぞれの構成に対して考えられるいくつかの振る舞いを示します。この一連のビューポイントは、システムの設計に焦点を当てています。上記は一例であり、この他にも設計に関連するビューポイントがある可能性があります。たとえば、第3章「システムとインタフェース」で説明したインタフェース関連のビューポイントもすべてこの設計パースペクティブ(Design Perspective)に含まれることになります。設計パースペクティブ(Design Pcrspective)をシステムアーキテクチャと呼ぶことがあることも指摘しておきます。たしかに、アーキテクチャにはすべての設計視点が含まれることになりますが、アーキテクチャはもっと広い範囲に及びます。たとえば、第4章「ライフサイクル」で示したライフサイクルパースペクティブ(Lifc Cyclc Pcrspective)、
# 第7章 設計のモデリング

適用されることがわかります。すなわち、論理システム要素は、システムまたはコンポーネントのシステム要素には適用されないことが推測できます。ビューポイントが存在しなければならない理由が示されましたので、ビューポイント定義ビューを検討することにしましょう。ビューポイント定ビューを定義するビューポイント定義ビュー(Ⅵcwpoint Deinition Ⅵew)は、ビューポイントに含まれるオントロジー要素を定義しており、以下のように示されます。●どのオントロジー要素がビューポイントにて許容されていますか?●どのオントロジー要素がビューポイントにて任意とされていますか?●どのオントロジー要素がビューポイントにて禁止されていますか?ビューポイント定義ビューでは1つのビューポイントに焦点を当て、選択されるオントロジー要素および要素間の関係性に注目します。次のダイアグラムを見てください。Logical SystemStructure(onlology elem€ntDSubsystem(ontology element)Logical(ontology element))System Element1¨(ontology element)interacts with > Assembly図7.26 論理システム構造ビューポイントのビューポイント定義ビュー図7.26は、SysMLのブロック定義図を使用し、論理システム構造ビューポイントのビューポイント定義ビューを示しています。ビューポイント定義ビューは、ビューポイントにて記述されるすべてのビューで許容さフイ/1.interacts withれる内容を正確に定義するため、ビューポイント定義ビューは非常に重要です。このビューポイントは常に以下の情報を合みます。●ビューポイント名<<viewpoin≫>でステレオタイプ化された、このビューの焦点となるビューポイントの名前。ここで特定されるビューポイントは、図7.24で示されたビューポイント関係ビューに由来するものでなければなりません。●オントロジー要素くくOnt01ogy element>>でステレオタイプ化された、いくつかのオントロジー要素。それぞれのオントロジー要素は、図7.3で示されたオントロジー定義ビューに由来するものでなければなりません。このビューポイントに関するビューで正当なオントロジー要素は以下の2つです。●)論理自勺 (Logical)論理システム要素を示します。機能的(Functional)と物理的(Physical)の2種類ではないことを示しており、本ビューポイントの範囲を制限するため、この定義は重要です。●サブシステム(Subsystem)とアセンブリ(Assembly)システム(System)とコンポーネント(Componcnt)の両方ではないことを示すため重要です。このような範囲に関する説明は、ビューポイント定義ビューを明示的に定義することがいかに重要であるかを示します。また、論理システム構造ビューポイント(Logical SystcmStructurc ⅥcwpOint)とシステム要素(System Elemcnt)との間に集約関連(Aggrcgation)が存在しないため、システム要素(System Element)はビューポイントに含まれないという点に注意が必要です。なぜなら、システム要素(System Element)は、直接のインスタンスをもたない抽象的な要素であり、ビューポイントに明示的に含まれないためです。ビューポイントとそれぞれのビューポイント上で認められるオントロジー要素は、いくつかのルールにて制約されます。このルールは、設計パースペクティブのためのルールセット定義ビュー(Rulcsct Denn􈎹 on Ⅵew)で説明されます。レールセットビューを定義するルールセット定義ビュー(Rulcset Dcnn􈎹 on Ⅵew)は、モデルがフレームヮークと一貫性をもつことを保証するため、モデルに適用するルールを特定して定義します。ノイ2ノ
# 第7章 設計のモデリング

ルールは、主にオントロジー定義ビューとビューポイント関係ビューにもとづいています。いずれの場合も、存在する主要な関係性と多重度を特定することでルールが定義されます。●ビューポイント定義ビュー上のビューポイント間●オントロジー定義ビュー上のオントロジー要素間ルールのいくつかの例を示します。次のダイアグラムを見てください。図7.27 ルールセット定義ビューの例図7.27は、SysMLのブロック定義図を使用し、SysMLのルールセット定義ビューを示しています。図7.27のそれぞれのブロックは、オントロジー定義ビューまたはビューポイント関係ビューのいずれかから派生したルールです。これらのルールは以下のように定義されています。●ルール1:それぞれのシステム要素は、その抽象型とシステム型にて定義されなければなりません(E¨h systcm element must be denned in b・ms ofits abstracttype and system type)図7.3のオントロジー定義ビューから派生したルールで、それぞれのシステム要素にはSysMLの識別器(Discn􈎹 nator)で定義された2種類の異なる特化(Spccialization)が関連付けられていることを示しています。●ルール2:それぞれの機能割り当てビューは、少なくとも1つの関連する振る舞いビューをもたなければなりません(E¨h function a1location Ⅵew must havc at least onefunction behavior vicw associated with it)図7.24に示したビューポイント関係ビューから派生したルールです。●ルール3:それぞれの物理システム構成ビューは、少なくとも1つの関連するシステム振る舞いビューをもたなければなりません(Each physical system conngur􈎹 on vicwmust havc atleast one System Bchavior Ⅵew associated with it)(ruleDRulelEach system elementmust be defined interms of its abstracttype and system type.<rulen*ule2Each function31:OCattOn VieW mu試have atleast onefttnctiott behavior viewessocieted with it.te rulenRule3EaCh phYSic311 systemconttguratton viewry、ust have atleast onesystem beheVior VieW議ssociated with it、ノイリ図7.24に示したビューポイント関係ビューから派生したルールです。ルールは、ビューポイントを示すビューポイント関係ビュー、そしてオントロジー要素を示すオントロジー定義ビューから派生していることに注目してください。実際のルールの記述自体は、ビューポイントのインスタンスであるビュー、そしてオントロジー要素のインスタンスに適用されます。他にもルールを定義することができますが、すべての関係性がルールになるわけではありません。どれをルールとするかはモデラーの判断次第です。これにより、システム設計に関連するビューポイントが定義されました。この後、こちらを本書全体で使用されるMBSEフレームヮーク全体の一部として使用します。まとめ設計の基本的な問題について説明してきました。設計とは、あるニーズにて特定された固有の問題に対して解決策を提供することです。設計には大きく2つのレベルがあり、一般にアーキテクチャ設計および詳細設計と呼ばれています。アーキテクチャ設計は抽象度が高く、システムおよびサブシステムのような高いレベルで適用されます。詳細設計は解決策全体の詳細な側面であり、サブシステム、アセンブリ、コンポーネントの構造に焦点を当てます。
# 第7章 設計のモデリング

次章では、本章で示した設計ビューの検証および妥当性確認のモデリンググ技法を紹介します。演習問題●図7.3のオントロジー定義ビューを再確認し、これがあなたの組織にどのように適用されるかを検討してください。組織のニーズを反映させるため、必要であればシステム要素を異なる種類に変更してください。●「機能(Function)」という用語と、それがあなたの組織の中でどのような意味をもつかについて考えてください。この用語に対するあなたの固有の解釈を反映させるために、オントロジーを更新してください。本章で使用した設計関連の用語と、第6章「ニーズと要求」で使用したニーズ関連の用語の両方を関連付けてください。●図7.11と図7.12で示された機能の割り当てを視覚化する2つの方法を比較してください。どちらを望ましいと考えるか、そしてその理由を説明してください。●図7.14と図7.3で示したオントロジーとの間に矛盾があります。この矛盾を見つけ、オントロジーを修正してください。●図7.24のビューポイント関係ビューに対して、アーキテクチャのビューポイント関係ビューを作成するために重要だと思われる他の観点を追加してください。●図7.24で示した少なくとも1つのビューポイントに対して、ビューポイントコンテキストビューとビューポイント定義ビューを定義してください。参考文献● (Holt&Perry 2019)Holt,J.D.and Pcry,S.A。(2019)SysM:L for Systeins Engineering一arnodel― based approach.′ I｀hird edition.1〕E'I｀ Publishing,Stevenage.UK,2019ノイメ