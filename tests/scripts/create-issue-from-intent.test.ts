/**
 * Create Issue from Intent Tests (Issue #47)
 */
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import type Anthropic from '@anthropic-ai/sdk';
import type { Octokit } from '@octokit/rest';

// =============================================================================
// Types
// =============================================================================

interface GeneratedIssue {
  title: string;
  summary: string;
  goal: string;
  context: string;
  constraints: string[];
  acceptanceCriteria: string[];
  destInput: {
    outcomeAssessment: {
      currentState: string;
      targetState: string;
      progress: 'better' | 'same' | 'worse';
    };
    safetyAssessment: {
      feedbackLoops: 'present' | 'absent' | 'harmful';
      safetyConstraints: string[];
      violations: string[];
    };
  };
  labels: string[];
}

// =============================================================================
// Mock Functions
// =============================================================================

/**
 * Mock AI Issue generation
 */
function mockGenerateIssueFromIntent(intent: string): GeneratedIssue {
  // Truncate title if too long (max 80 chars)
  let title = intent.length > 60 ? `${intent.slice(0, 60)}...` : intent;
  title = `${title} - Generated Issue`;
  if (title.length > 80) {
    title = title.slice(0, 77) + '...';
  }

  // Determine priority based on intent keywords
  let priority = 'priority:P2-Medium';
  const lowerIntent = intent.toLowerCase();
  if (
    lowerIntent.includes('critical') ||
    lowerIntent.includes('security') ||
    lowerIntent.includes('vulnerability') ||
    lowerIntent.includes('urgent')
  ) {
    priority = 'priority:P0-Critical';
  } else if (
    lowerIntent.includes('important') ||
    lowerIntent.includes('high priority') ||
    lowerIntent.includes('blocking')
  ) {
    priority = 'priority:P1-High';
  } else if (lowerIntent.includes('low priority') || lowerIntent.includes('nice to have')) {
    priority = 'priority:P3-Low';
  }

  return {
    title,
    summary: `This issue addresses: ${intent.slice(0, 100)}${intent.length > 100 ? '...' : ''}`,
    goal: `Implement ${intent.slice(0, 100)} to improve the system`,
    context: `User requested: ${intent.slice(0, 200)}${intent.length > 200 ? '...' : ''}`,
    constraints: ['Must maintain backward compatibility', 'Should follow existing patterns'],
    acceptanceCriteria: [
      'Feature is implemented',
      'Tests pass',
      'Documentation is updated',
    ],
    destInput: {
      outcomeAssessment: {
        currentState: 'Feature does not exist',
        targetState: 'Feature is fully implemented and tested',
        progress: 'better',
      },
      safetyAssessment: {
        feedbackLoops: 'present',
        safetyConstraints: [
          'No breaking changes to existing APIs',
          'All tests must pass',
        ],
        violations: [],
      },
    },
    labels: ['type:feature', 'complexity:medium', priority],
  };
}

/**
 * Format Issue body
 */
function formatIssueBody(generated: GeneratedIssue): string {
  return `## Summary
${generated.summary}

## Goal
${generated.goal}

## Context
${generated.context}

## Constraints
${generated.constraints.map((c) => `- ${c}`).join('\n')}

## Acceptance Criteria
${generated.acceptanceCriteria.map((c) => `- [ ] ${c}`).join('\n')}

---

## ðŸŽ¯ DEST Judgment

### Outcome Assessment
**Current State**: ${generated.destInput.outcomeAssessment.currentState}
**Target State**: ${generated.destInput.outcomeAssessment.targetState}
**Progress**: ${generated.destInput.outcomeAssessment.progress}

### Safety Assessment
**Feedback Loops**: ${generated.destInput.safetyAssessment.feedbackLoops}

**Safety Constraints**:
${generated.destInput.safetyAssessment.safetyConstraints.map((c) => `- ${c}`).join('\n')}

**Violations**: ${
    generated.destInput.safetyAssessment.violations.length === 0
      ? 'None'
      : generated.destInput.safetyAssessment.violations.join(', ')
  }

---
*Generated by Luna Intent-to-Issue*`;
}

// =============================================================================
// Tests
// =============================================================================

describe('create-issue-from-intent', () => {
  describe('Issue Generation', () => {
    it('should generate valid Issue structure from intent', () => {
      const intent = 'Add user authentication';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.title).toBeTruthy();
      expect(result.title).toContain(intent);
      expect(result.summary).toBeTruthy();
      expect(result.goal).toBeTruthy();
      expect(result.context).toBeTruthy();
      expect(result.constraints).toBeInstanceOf(Array);
      expect(result.constraints.length).toBeGreaterThan(0);
      expect(result.acceptanceCriteria).toBeInstanceOf(Array);
      expect(result.acceptanceCriteria.length).toBeGreaterThan(0);
    });

    it('should include DEST judgment fields', () => {
      const intent = 'Implement caching layer';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.destInput).toBeDefined();
      expect(result.destInput.outcomeAssessment).toBeDefined();
      expect(result.destInput.safetyAssessment).toBeDefined();

      // Outcome Assessment
      expect(result.destInput.outcomeAssessment.currentState).toBeTruthy();
      expect(result.destInput.outcomeAssessment.targetState).toBeTruthy();
      expect(['better', 'same', 'worse']).toContain(
        result.destInput.outcomeAssessment.progress
      );

      // Safety Assessment
      expect(['present', 'absent', 'harmful']).toContain(
        result.destInput.safetyAssessment.feedbackLoops
      );
      expect(result.destInput.safetyAssessment.safetyConstraints).toBeInstanceOf(
        Array
      );
      expect(result.destInput.safetyAssessment.violations).toBeInstanceOf(Array);
    });

    it('should include appropriate labels', () => {
      const intent = 'Add API rate limiting';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.labels).toBeInstanceOf(Array);
      expect(result.labels.length).toBeGreaterThan(0);

      // Should have type label
      const hasTypeLabel = result.labels.some((label) =>
        label.startsWith('type:')
      );
      expect(hasTypeLabel).toBe(true);

      // Should have complexity label
      const hasComplexityLabel = result.labels.some((label) =>
        label.startsWith('complexity:')
      );
      expect(hasComplexityLabel).toBe(true);

      // Should have priority label
      const hasPriorityLabel = result.labels.some((label) =>
        label.startsWith('priority:')
      );
      expect(hasPriorityLabel).toBe(true);
    });
  });

  describe('Issue Body Formatting', () => {
    it('should format Issue body correctly', () => {
      const intent = 'Add dark mode';
      const generated = mockGenerateIssueFromIntent(intent);
      const body = formatIssueBody(generated);

      expect(body).toContain('## Summary');
      expect(body).toContain('## Goal');
      expect(body).toContain('## Context');
      expect(body).toContain('## Constraints');
      expect(body).toContain('## Acceptance Criteria');
      expect(body).toContain('## ðŸŽ¯ DEST Judgment');
      expect(body).toContain('### Outcome Assessment');
      expect(body).toContain('### Safety Assessment');
      expect(body).toContain('*Generated by Luna Intent-to-Issue*');
    });

    it('should format constraints as markdown list', () => {
      const intent = 'Optimize database queries';
      const generated = mockGenerateIssueFromIntent(intent);
      const body = formatIssueBody(generated);

      generated.constraints.forEach((constraint) => {
        expect(body).toContain(`- ${constraint}`);
      });
    });

    it('should format acceptance criteria as checklist', () => {
      const intent = 'Add logging system';
      const generated = mockGenerateIssueFromIntent(intent);
      const body = formatIssueBody(generated);

      generated.acceptanceCriteria.forEach((criterion) => {
        expect(body).toContain(`- [ ] ${criterion}`);
      });
    });

    it('should display "None" when no violations exist', () => {
      const intent = 'Refactor code structure';
      const generated = mockGenerateIssueFromIntent(intent);
      generated.destInput.safetyAssessment.violations = [];
      const body = formatIssueBody(generated);

      expect(body).toContain('**Violations**: None');
    });

    it('should list violations when they exist', () => {
      const intent = 'Update API endpoints';
      const generated = mockGenerateIssueFromIntent(intent);
      generated.destInput.safetyAssessment.violations = [
        'Breaking change',
        'Missing tests',
      ];
      const body = formatIssueBody(generated);

      expect(body).toContain('**Violations**: Breaking change, Missing tests');
    });
  });

  describe('Input Validation', () => {
    it('should handle empty intent gracefully', () => {
      const intent = '';

      expect(() => {
        if (!intent || intent.trim().length === 0) {
          throw new Error('Intent cannot be empty');
        }
      }).toThrow('Intent cannot be empty');
    });

    it('should handle very long intent', () => {
      const intent = 'A'.repeat(10000);
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.title).toBeTruthy();
      expect(result.title.length).toBeLessThan(200); // Reasonable title length
    });

    it('should handle special characters in intent', () => {
      const intent = 'Add feature with <script>alert("XSS")</script>';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.title).toBeTruthy();
      expect(result.summary).toBeTruthy();
      // Should not execute script, just include as text
    });
  });

  describe('Label Generation', () => {
    it('should categorize simple features correctly', () => {
      const intent = 'Add logout button';
      const result = mockGenerateIssueFromIntent(intent);

      const complexityLabel = result.labels.find((l) =>
        l.startsWith('complexity:')
      );
      expect(complexityLabel).toBeDefined();
      expect(['complexity:simple', 'complexity:medium']).toContain(
        complexityLabel
      );
    });

    it('should categorize complex features correctly', () => {
      const intent =
        'Implement real-time collaboration with WebSockets and conflict resolution';
      const result = mockGenerateIssueFromIntent(intent);

      // For this test, we'll just verify that it has a complexity label
      const complexityLabel = result.labels.find((l) =>
        l.startsWith('complexity:')
      );
      expect(complexityLabel).toBeDefined();
    });

    it('should assign priority based on intent urgency', () => {
      const intent = 'Fix critical security vulnerability';
      const result = mockGenerateIssueFromIntent(intent);

      const priorityLabel = result.labels.find((l) => l.startsWith('priority:'));
      expect(priorityLabel).toBeDefined();
      // Critical issues should have high priority
      expect(['priority:P0-Critical', 'priority:P1-High']).toContain(
        priorityLabel
      );
    });
  });

  describe('Progress Assessment', () => {
    it('should default to "better" for new features', () => {
      const intent = 'Add new analytics dashboard';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.destInput.outcomeAssessment.progress).toBe('better');
    });

    it('should use "better" for improvements', () => {
      const intent = 'Improve performance of API endpoints';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.destInput.outcomeAssessment.progress).toBe('better');
    });

    it('should use "better" for bug fixes', () => {
      const intent = 'Fix memory leak in worker threads';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.destInput.outcomeAssessment.progress).toBe('better');
    });
  });

  describe('Safety Assessment', () => {
    it('should default to "present" feedback loops for normal features', () => {
      const intent = 'Add user settings page';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.destInput.safetyAssessment.feedbackLoops).toBe('present');
    });

    it('should include safety constraints', () => {
      const intent = 'Update authentication system';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.destInput.safetyAssessment.safetyConstraints.length).toBeGreaterThan(
        0
      );
    });

    it('should default to no violations for new features', () => {
      const intent = 'Add notification system';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.destInput.safetyAssessment.violations.length).toBe(0);
    });
  });

  describe('Edge Cases', () => {
    it('should handle single-word intent', () => {
      const intent = 'refactor';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.title).toBeTruthy();
      expect(result.summary).toBeTruthy();
      expect(result.goal).toBeTruthy();
    });

    it('should handle intent with multiple sentences', () => {
      const intent =
        'Add user authentication. Support OAuth and JWT. Include refresh tokens.';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.title).toBeTruthy();
      expect(result.summary).toBeTruthy();
      expect(result.context).toContain(intent);
    });

    it('should handle intent with technical jargon', () => {
      const intent =
        'Implement CQRS pattern with Event Sourcing for aggregate persistence';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.title).toBeTruthy();
      expect(result.summary).toBeTruthy();
    });

    it('should handle intent in different languages (Japanese)', () => {
      const intent = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼æ©Ÿèƒ½ã‚’è¿½åŠ ';
      const result = mockGenerateIssueFromIntent(intent);

      expect(result.title).toBeTruthy();
      expect(result.summary).toBeTruthy();
      expect(result.title).toContain(intent);
    });
  });

  describe('Error Handling Scenarios', () => {
    it('should validate required fields in generated Issue', () => {
      const intent = 'Add new feature';
      const result = mockGenerateIssueFromIntent(intent);

      // All required fields must be present
      expect(result.title).toBeTruthy();
      expect(result.summary).toBeTruthy();
      expect(result.goal).toBeTruthy();
      expect(result.context).toBeTruthy();
      expect(result.constraints).toBeDefined();
      expect(result.acceptanceCriteria).toBeDefined();
      expect(result.destInput).toBeDefined();
      expect(result.labels).toBeDefined();
    });

    it('should ensure DEST fields are properly structured', () => {
      const intent = 'Optimize performance';
      const result = mockGenerateIssueFromIntent(intent);

      // Validate Outcome Assessment structure
      expect(result.destInput.outcomeAssessment.currentState).toBeTruthy();
      expect(result.destInput.outcomeAssessment.targetState).toBeTruthy();
      expect(result.destInput.outcomeAssessment.progress).toBeTruthy();

      // Validate Safety Assessment structure
      expect(result.destInput.safetyAssessment.feedbackLoops).toBeTruthy();
      expect(
        Array.isArray(result.destInput.safetyAssessment.safetyConstraints)
      ).toBe(true);
      expect(Array.isArray(result.destInput.safetyAssessment.violations)).toBe(
        true
      );
    });

    it('should handle JSON parsing errors gracefully', () => {
      const invalidJson = '{ invalid json }';

      expect(() => {
        JSON.parse(invalidJson);
      }).toThrow();
    });

    it('should validate progress enum values', () => {
      const validProgress: Array<'better' | 'same' | 'worse'> = [
        'better',
        'same',
        'worse',
      ];
      const intent = 'Test progress validation';
      const result = mockGenerateIssueFromIntent(intent);

      expect(validProgress).toContain(
        result.destInput.outcomeAssessment.progress
      );
    });

    it('should validate feedbackLoops enum values', () => {
      const validFeedbackLoops: Array<'present' | 'absent' | 'harmful'> = [
        'present',
        'absent',
        'harmful',
      ];
      const intent = 'Test feedback loops validation';
      const result = mockGenerateIssueFromIntent(intent);

      expect(validFeedbackLoops).toContain(
        result.destInput.safetyAssessment.feedbackLoops
      );
    });
  });

  describe('Integration Scenarios', () => {
    it('should generate Issue suitable for Coordinator execution', () => {
      const intent = 'Add CI/CD pipeline';
      const result = mockGenerateIssueFromIntent(intent);

      // Must have clear acceptance criteria for Coordinator
      expect(result.acceptanceCriteria.length).toBeGreaterThan(0);

      // Must have DEST judgment for execution decisions
      expect(result.destInput).toBeDefined();
      expect(result.destInput.outcomeAssessment).toBeDefined();
      expect(result.destInput.safetyAssessment).toBeDefined();
    });

    it('should format body compatible with GitHub markdown', () => {
      const intent = 'Add documentation';
      const generated = mockGenerateIssueFromIntent(intent);
      const body = formatIssueBody(generated);

      // Should use standard markdown headers
      expect(body).toContain('##');

      // Should use markdown lists
      expect(body).toContain('- ');

      // Should use markdown checkboxes
      expect(body).toContain('- [ ]');
    });
  });

  describe('Dry-run Mode', () => {
    it('should preview Issue without creating it', () => {
      const intent = 'Add search functionality';
      const generated = mockGenerateIssueFromIntent(intent);
      const body = formatIssueBody(generated);

      // In dry-run, we should be able to preview all content
      expect(generated.title).toBeTruthy();
      expect(body).toBeTruthy();
      expect(generated.labels.length).toBeGreaterThan(0);

      // Verify preview includes all sections
      expect(body).toContain('## Summary');
      expect(body).toContain('## ðŸŽ¯ DEST Judgment');
    });
  });
});
